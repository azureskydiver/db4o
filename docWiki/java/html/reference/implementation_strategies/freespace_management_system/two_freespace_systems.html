<html>
  <head>
    <META http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Two Freespace Systems</title>
    <link rel="stylesheet" type="text/css" href="../../../style.css">
  </head>
  <body>
    <div class="CommonContent">
      <div class="CommonContentArea">
        <h1>Two Freespace Systems</h1>

<p>db4o comes with two freespace systems, one holds all freespace information in RAM, the other uses the internal indexing architecture. You can configure db4o to use either of the two by calling</p>

<span class="java"></p>
<p>Java: <code>configuration.freespace().useRamSystem()</code> </p>
<p></span>



<p>or</p>

<span class="java"></p>
<p>Java: <code>configuration.freespace().useIndexSystem() </code></p>
<p></span>


<p>
This call should be made before you open the database for the first time</p>
<p>By default db4o uses <b>RAM freespace management system</b>. The information about free slots is loaded into memory on opening a database file and discarded on closing it. This system is quite fast, but it has its downside:</p>
<ol>
<li>Higher RAM usage during operation.</li>
<li>Loss of freespace upon abnormal termination. That is done for security reasons and freespace can be reclaimed using defragmentation.</li>
</ol>
<p>
RAM-based freespace management is a good performance solution, but it can be insufficient for the systems with limited RAM resources and high probability of abnormal system termination (power failure on mobile devices).</p>
<p>In order to meet the requirements of such environments new <b>index-based freespace management system</b> was built. It solves the problems of RAM-based system:</p>
<ol>
<li>
RAM usage is kept at the minimum, as the system always operates from file.</li>
<li>No freespace is lost on abnormal system termination (database file won't grow unnecessarily).</li>
</ol>
<p>
How it works?:
</p><ul>
<li>The system uses existing index functionality to keep information about available freespace</li>
<li>Index operates against the file, not against memory</li>
<li>For every new write to the database file the system tries to find a freed slot, which is at least the size needed or greater, traversing freespace index</li>
<li>When an object is updated or deleted, its 'old' slot is added to the freespace index</li>
<li>This index system is transactional (no information is lost upon abnormal system termination)</li>
<li>It stores diffs in a tree in RAM (index add/remove) together with nodes that represent parts or the whole index, as it exists in the file.</li>
</ul>
<p>Index-based freespace system can show poorer performance compared to RAM-based system, as file access for index traversal it comparatively slow. </p>
<p>However, index-based freespace system can be a reasonable solution for mobile devices, where file access is not much slower than RAM-access, and ACID transactions together with low memory consumption are most valuable factors.</p></div>
    </div>
    <div id="footer">
					This revision (7) was last Modified 2007-04-23T08:08:32 by Tetyana.
				</div>
  </body>
</html>