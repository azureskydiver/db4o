<html>
  <head>
    <META http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>db4o Replication System (dRS)</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
  </head>
  <body>
    <div class="CommonContent">
      <div class="CommonContentArea">
        <h1>db4o Replication System (dRS)</h1><div id="TOC"><div id="TOCinner"><span class="TOCtitle">Contents</span><div class="TOCcontents"><ul><li><a href ="#Under the Hood">Under the Hood</a></li><li><a href ="#Synchronizing Existing Database Files">Synchronizing Existing Database Files</a></li></ul></li></ul></div></div></div>
<p></p>
<p>db4o Replication System (dRS) provides functionality to periodically synchronize 
databases that work disconnected from each other, such as remote autonomous 
servers or handheld devices synchronizing with central servers.</p>
<p>In order 
to use replication, the following configuration settings have to be called 
before a database file is created or opened:</p>


 </p>
<p>(See the section below on how to enable replication for existing 
databases)</p>
<p>Both settings can also be configured on a per-class basis:</p>



<p>Suppose we have opened two ObjectContainers from two different databases called 
"handheld" and "desktop", that we want to replicate. This is how we do it: </p>





<p>That's all there is to it.</p>
<p>We are using a query that will return all 
objects but we could use any query we like to constrain the objects we 
want.</p>
<p>Calling whereModified() will add a constraint to the query so that 
it only returns the objects that have actually been modified since the last 
replication between both the containers in question.</p>
<p>After replication 
commit, all modified objects (INCLUDING THE ONES THAT WERE NOT REPLICATED) are 
considered to be "in sync" and will not show up in future "where modified" 
queries, unless they are modified again.</p>
<a name="Under the Hood"></a><h2>Under the Hood</h2>
<p>Let's take a look at the necessary configuration calls to tell db4o to generate 
version numbers and UUIDs:&lt;</p>
<ol>
<li>An object's version number indicates the 
last time an object was modified. It is the database version at the moment of 
the modification. The database version starts at zero and is incremented every 
time a transaction is commited.</li>
<li>UUIDs are object IDs that are unique 
across all databases created with db4o. That is achieved by having the 
database's creation timestamp as part of its objects' UUIDs. Manually copying 
db4o database files can produce duplicate UUIDs, of course.</li>
</ol>
<p>When the 
replication process is commited, the lowest database version number among both 
databases is set to be equal to the highest. After replication commit, 
therefore, both databases have the same version number and are "in sync".</p>
<a name="Synchronizing Existing Database Files"></a><h2>Synchronizing Existing Database Files</h2>
<p>As we learned in the last sections, Db4o.configure().generateUUIDs() and 
Db4o.configure().generateVersionNumbers() (or its objectClass counterparts) 
must be called before storing any objects to a data file because db4o 
replication needs object versions and UUIDs to work. This implies that objects 
in existing data files stored without the correct settings can't be 
replicated.</p>
<p>Fortunately enabling replication for existing data files is a 
very simple process:</p>
<p>We just need to use the Defragment tool in 
com.db4o.tools (source code only) after enabling replication:</p>





<p>After a successful defragmentation our data files are ready for replication.</p></div>
    </div>
    <div id="footer">
					This revision (3) was last Modified 2006-11-13T20:42:50 by Tetyana.
				</div>
  </body>
</html>