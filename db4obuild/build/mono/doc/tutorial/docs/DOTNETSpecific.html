<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="stylesheet" type="text/css" href="docs.css">
</head>
<body><div id="pagecontainer"><table><tr><td width="5">&nbsp;</td><td><a name="DOTNETSpecific"></a><br>
<a name="outline562"></a><br><h1>21. .NET Specific Notes</h1><ul>
<a name="outline563"></a><br><h2>21.1. Enums</h2><br>
When dealing with .NET enumerated types we must face the fact&nbsp;that they are nothing more than glorified integer numbers. In other&nbsp;words, everything we know about how db4o handles integer values&nbsp;also applies to .NET enumerated types:&nbsp;it does not make sense to store, delete or retrieve enumerated values&nbsp;directly but to always use them as fields of other types.<br>
<br>
A very important implication of this similarity that might not be entirely&nbsp;obvious is in how db4o will handle enumerated values during a Query By Example.&nbsp;Let's consider the following (WRONG) example:<br>
<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>enum DoorState {<br>
&nbsp;&nbsp;Open,<br>
&nbsp;&nbsp;Closed<br>
}<br>
<br>
class Door { <br>
&nbsp;&nbsp;DoorState _state;<br>
&nbsp;&nbsp;public Door(DoorState state) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;_state = state;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
class Example {<br>
&nbsp;&nbsp;public static ObjectSet FindOpenDoors(ObjectContainer container) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return container.get(new Door(DoorState.Open));<br>
&nbsp;&nbsp;}<br>
}<br>
</code></td></tr></table>
<br>
The problem is in how the method FindOpenDoors tries to use the enumerated&nbsp;value DoorState.Open to retrieve only the specified subset of Door objects&nbsp;when the query in fact will return ALL Door instances regardless of their _state&nbsp;field value.<br>
<br>
This might seem intriguing at first but it's just a matter of&nbsp;understanding two things:<br>
<br>
1) QBE works by looking at the given prototype and filtering the system&nbsp;by only those fields which are not set to their default/null/zero value&nbsp;according to its underlying type;<br>
<br>
2) the DoorState enum declaration in our first example really means:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>enum DoorState {<br>
&nbsp;&nbsp;Open = 0,<br>
&nbsp;&nbsp;Closed = 1<br>
}<br>
</code></td></tr></table>
which implies that DoorState.Open is the default value for the DoorState type&nbsp;thus excluding it from the filter.<br>
<br>
There are two main strategies to cope with this situation:<br>
<br>
1) to use the SODA API and recode the Example class as:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>class Example {<br>
&nbsp;&nbsp;public static ObjectSet FindOpenDoors(ObjectContainer container) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;Query query = container.query();<br>
&nbsp;&nbsp;&nbsp;&nbsp;query.constrain(typeof(Door));<br>
&nbsp;&nbsp;&nbsp;&nbsp;query.descend("_state").constrain(DoorState.Open);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return query.execute();<br>
&nbsp;&nbsp;}<br>
}<br>
</code></td></tr></table>
<br>
2) to always reserve the first slot of an enumerate value by either&nbsp;explicitly naming it:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>enum DoorState {<br>
&nbsp;&nbsp;Uninitialized,<br>
&nbsp;&nbsp;Open,<br>
&nbsp;&nbsp;Closed<br>
}<br>
</code></td></tr></table>
or explicitly setting the value of every element:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>enum DoorState {<br>
&nbsp;&nbsp;Open = 1,<br>
&nbsp;&nbsp;Closed = 2<br>
}<br>
</code></td></tr></table>
<br>
<a name="outline564"></a><br><h2>21.2. Delegates and Events</h2><br>
Db4o rules for delegate fields are very straightforward:&nbsp;<b>delegates are simply not stored.</b><br>
<br>
Events and delegates are generally used for binding user interface elements&nbsp;and domain models together. The Db4o team felt that not storing&nbsp;delegate fields by default was more appropriate than opening&nbsp;what could potentially be a very nasty can of worms&nbsp;(just think of a text box bound to a Customer.Changed event).<br>
<br>
After careful thought we can easily add delegate persistence to our&nbsp;domain model by either installing translators for the delegate types&nbsp;of interest or reconnecting the necessary objects upon activation&nbsp;using callbacks.<br>
<br>
For details see the specific chapters on&nbsp;<a href="Translators.html#Translators">Translators</a>&nbsp;and&nbsp;<a href="Callbacks.html#Callbacks">Callbacks</a>.<br>
<br>
<br>
<br>
<br>
<br>
<br><br><br><small>--<br>generated by </small><a href="http://www.db4objects.com/doctor/" target=_top><small>Doctor</small></a><small> courtesy of </small><a href="http://www.db4objects.com" target=_top><small>db4objects Inc.</small></a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></td></tr></table></div></body></html>