<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="stylesheet" type="text/css" href="docs.css">
</head>
<body><div id="pagecontainer"><table><tr><td width="5">&nbsp;</td><td><a name="outline375"></a><br><h1>11. Tuning</h1><br>
The following is an overview over possible tuning switches&nbsp;that can be set when working with db4o. Users that do not&nbsp;care about performance may like to read this chapter also&nbsp;because it provides a side glance at db4o features with&nbsp;<em>Alternate Strategies</em>&nbsp;and some insight on how&nbsp;db4o works.<br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().discardFreeSpace(byteCount);<br>
</code></td></tr></table>
<br>
Recommended settings for byteCount:<br>
- Integer.MAX_VALUE will turn freespace management off<br>
- Moderate range: 10 to 50<br>
- Default built-in setting: 0<br>
<br>
<em>Advantage</em><br>
will reduce the RAM memory overhead and the speed loss from&nbsp;maintaining the freespace lists.<br>
<br>
<em>Effect</em><br>
When objects are updated or deleted, the space previously occupied&nbsp;in the database file is marked as "free", so it can be reused. db4o&nbsp;maintains two lists in RAM, sorted by address and by size. Adjacent&nbsp;entries are merged. After a large number of updates or deletes have&nbsp;been executed, the lists can become large, causing RAM&nbsp;consumption and performance loss for maintenance. With this&nbsp;method you can specify an upper bound for the byte slot size to&nbsp;discard.<br>
<br>
<em>Alternate Strategies</em><br>
Regular defragment will also keep the number of free space slots&nbsp;small. See:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
com.db4o.tools.Defragment<br>
</code></td></tr></table>
<br>
(supplied as source code insrc/com/db4o/tools)<br>
If defragment can be frequently run, it will also reclaim&nbsp;lost space and decrease the database file to the minimum size.&nbsp;Therefore #discardFreeSpace() may be a good tuning mechanism&nbsp;for setups with frequent defragment runs.<br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().weakReferences(false);<br>
</code></td></tr></table>
<br>
<em>Advantage</em><br>
will configure db4o to use hard direct references instead of weak&nbsp;references to control instantiated and stored objects.<br>
<br>
<em>Effect</em><br>
A db4o database keeps a reference to all persistent objects that are&nbsp;currently held in RAM, whether they were stored to the database in&nbsp;this session or instantiated from the database in this session.&nbsp;This is how db4o can "know" than an object is to be updated: Any&nbsp;"known" object must be an update, any "unknown" object will be&nbsp;stored as "new". (Note that the reference system will only be in&nbsp;place as long as an ObjectContainer is open. Closing and reopening an&nbsp;ObjectContainer will clean the references system of the ObjectContainer&nbsp;and all objects in RAM will be treated as "new" afterwards.) In the&nbsp;default configuration db4o uses weak references and a dedicated thread&nbsp;to clean them up after objects have been garbage collected by the VM.&nbsp;Weak references need extra ressources and the cleanup thread will&nbsp;have a considerable impact on performance since it has to be synchronized&nbsp;with the normal operations within the ObjectContainer. Turning off weak&nbsp;references will improve speed. <br>
The downside: To prevent memory consumption from growing consistantly,&nbsp;the application has to take care of removing unused objects from the db4o&nbsp;reference system by itself. This can be done by calling<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
ExtObjectContainer.purge(object);<br>
</code></td></tr></table>
<br>
<br>
<em>Alternate Strategies</em><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
ExtObjectContainer.purge(object);<br>
</code></td></tr></table>
<br>
can also be called in normal weak reference operation mode to remove&nbsp;an object from the reference cache. This will help to keep the reference&nbsp;tree as small as possible.&nbsp;After calling #purge(object) an object will be unknown to the&nbsp;ObjectContainer so this feature is also suitable for batch inserts. <br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().automaticShutDown(false);<br>
</code></td></tr></table>
<br>
<em>Advantage</em><br>
can prevent the creation of a shutdown thread on some platforms.<br>
<br>
<em>Effect</em><br>
On some platforms db4o uses a ShutDownHook to cleanly close all&nbsp;database files upon system termination. If a system is terminated&nbsp;without calling ObjectContainer#close() for all open&nbsp;ObjectContainers, these ObjectContainers will still be usable but&nbsp;they will not be able to write back their freespace management&nbsp;system back to the database file. Accordingly database files will be&nbsp;observed to grow.<br>
<br>
<em>Alternate Strategies</em><br>
Database files can be reduced to their minimal size with<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
com.db4o.tools.Defragment<br>
</code></td></tr></table>
<br>
(supplied as source code in /src/com/db4o/tools)<br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().callbacks(false);<br>
</code></td></tr></table>
<br>
<em>Advantage</em><br>
will prevent db4o from looking for callback methods in all persistent&nbsp;classes on system startup.<br>
<br>
<em>Effect</em><br>
Upon system startup, db4o will scan all persistent classes for&nbsp;methods with the same signature as the methods defined in&nbsp;com.db4o.ext.ObjectCallbacks, even if the interface is not&nbsp;implemented. db4o uses reflection to do so and on constrained&nbsp;environments this can consume quite a bit of time. If callback&nbsp;methods are not used by the application, callbacks can be turned&nbsp;off safely.<br>
<br>
<em>Alternate Strategies</em><br>
Class configuration features are a good alternative to callbacks.&nbsp;The most recommended mechanism to cascade updates is:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().objectClass("yourPackage.yourClass").cascadeOnUpdate(true);<br>
</code></td></tr></table>
<br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().detectSchemaChanges(false);<br>
</code></td></tr></table>
<br>
<em>Advantage</em><br>
will prevent db4o from analysing the class structure upon opening a&nbsp;database file.<br>
<br>
<em>Effect</em><br>
Upon system startup, db4o will use reflection to scan the structure&nbsp;of all persistent classes. This process can take some time, if a large&nbsp;number of classes are present in the database file. For the best&nbsp;possible startup performance on "warm" database files (all classes&nbsp;present), this feature can be turned off.<br>
<br>
<em>Alternate Strategies</em><br>
Instead of using one database file to store a huge and complex&nbsp;class structure, a system may be more flexible and faster, if&nbsp;multiple database files are used. In a client/server setup, database&nbsp;files can also be switched from the client side with<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
((ExtClient)objectContainer).switchToFile(databaseFile);<br>
</code></td></tr></table>
<br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().lockDatabaseFile(false);<br>
</code></td></tr></table>
<br>
<em>Advantage</em><br>
will prevent the creation of a lock file thread on Java platforms&nbsp;without NIO (< JDK 1.4.1).<br>
<br>
<em>Effect</em><br>
If file locking is not available on the system, db4o will regularily&nbsp;write a timestamp lock information to the database file, to prevent&nbsp;other VM sessions from accessing the database file at the same&nbsp;time. Uncontrolled concurrent access would inevitably lead to&nbsp;corruption of the database file. If the application ensures that it can&nbsp;not be started multiple times against the database file, db4o file&nbsp;locking may not be necessary.<br>
<br>
<em>Alternate Strategies</em><br>
Database files can safely be opened from multiple sessions in readonly<br>
mode. Use:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().readOnly(true)<br>
</code></td></tr></table>
<br>
<br>
<br>
<b>Measure</b><br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().testConstructors(false);<br>
</code></td></tr></table>
<br>
<em>Advantage</em><br>
will prevent db4o from creating a test instance of persistent classes&nbsp;upon opening a database file.<br>
<br>
<em>Effect</em><br>
Upon system startup, db4o attempts to create a test instance of all&nbsp;persistent classes, to ensure that a public zero-parameter&nbsp;constructor is present. This process can take some time, if a large&nbsp;number of classes are present in the database file. For the best&nbsp;possible startup performance this feature can be turned off.<br>
<br>
<em>Alternate Strategies</em><br>
In any case it's always good practice to create a zero-parameter&nbsp;constructor. If this is not possible because a class from a third party&nbsp;is used, it may be a good idea to write a translator that translates&nbsp;the third party class to one's own class. The dowload comes with&nbsp;the source code of the preconfigured translators in<br>
src/com/db4o/samples/translators.<br>
The default configuration can be found in the above folder in the file<br>
Default.java/Default.cs<br>
Take a look at the way the built-in translators work to get an idea&nbsp;how to write a translator. It just requires implementing 3 (4 for&nbsp;ObjectConstructors) methods and configuring db4o to use a&nbsp;translator on startup with<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code><br>
Db4o.configure().objectClass("yourPackage.yourClass").translate()<br>
</code></td></tr></table>
<br><br><br><small>--<br>generated by </small><a href="http://www.db4objects.com/doctor/" target=_top><small>Doctor</small></a><small> courtesy of </small><a href="http://www.db4objects.com" target=_top><small>db4objecs Inc.</small></a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></td></tr></table></div></body></html>