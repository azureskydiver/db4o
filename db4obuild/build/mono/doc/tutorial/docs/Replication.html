<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="stylesheet" type="text/css" href="docs.css">
</head>
<body><div id="pagecontainer"><table><tr><td width="5">&nbsp;</td><td><a name="Replication"></a><br>
<a name="outline564"></a><br><h1>20. Replication</h1><br>
db4o provides replication functionality to periodically synchronize&nbsp;databases that work disconnected from eachother, such as remote autonomous servers&nbsp;or handheld devices synchronizing with central servers. <br>
<br>
In order to use replication, the following configuration settings have&nbsp;to be called before a database file is created or opened:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>Db4o.configure().generateUUIDs(Integer.MAX_VALUE); <br>
Db4o.configure().generateVersionNumbers(Integer.MAX_VALUE);</code></td></tr></table>
<br>
(See the <a href="Replication.html#ReplicatingExisting">section below</a>&nbsp;on how to enable replication for&nbsp;existing databases that were )<br>
<br>
Both settings can also be configured on a per-class basis:<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>Db4o.configure().objectClass(Foo.class).generateUUIDs(true); <br>
Db4o.configure().objectClass(Foo.class).generateVersionNumbers(true);</code></td></tr></table>
<br>
<br>
<br>
Now suppose we have opened two ObjectContainers from two different databases called&nbsp;"handheld" and "desktop", that we want to&nbsp;replicate. This is how we do it:<br>
<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>ReplicationProcess replication = <br>
&nbsp;&nbsp;desktop.ext().replicationBegin(handheld, new ReplicationConflictHandler() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;public Object resolveConflict(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplicationProcess replicationProcess, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object a, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object b) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}});<br>
replication.setDirection(desktop, handheld);</code></td></tr></table>
<br>
For conflict resolution the ObjectContainer on which replicationBegin() was called, is&nbsp;treated as container "A", the other one is container "B". Both&nbsp;ObjectContainers are treated equally in all other respects.<br>
<br>
db4o replication is bi-directional by default. The setDirection() call above is used&nbsp;to ensure that changes will only be replicated from the "desktop" to the "handheld".&nbsp;In that case, replication is said to be "directed".<br>
<br>
A conflict occurs when an object to be replicated has been modified in both&nbsp;ObjectContainers.&nbsp;db4o cannot arbitrarily pick one side, so the ReplicationConflictHandler we passed is&nbsp;called to resolve the conflict. If the ReplicationConflictHandler returns null, no&nbsp;changes are&nbsp;replicated. In the case of directed replication, such as our example above, a conflict&nbsp;also occurs when an object has been modified only in the destination container. In our&nbsp;example, the ReplicationConflictHandler always determines that the object from container "A"&nbsp;(desktop) will "win" the conflict, thus overriding any changes made in container "B"&nbsp;(handheld).<br>
<br>
Do all objects always get replicated? No. How do we decide which objects get replicated?&nbsp;Like this:<br>
<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>Query q = desktop.query();<br>
 replication.whereModified(q);<br>
 ObjectSet replicationSet = q.execute();<br>
 while (replicationSet.hasNext()) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;replication.replicate(replicationSet.next());<br>
 }<br>
 replication.commit();</code></td></tr></table>
<br>
That's all there is to it.<br>
<br>
We are using a query that will return all objects but we could use any query we like to&nbsp;constrain the objects we want.<br>
<br>
Calling whereModified() will add a constraint to the query so that it only returns the&nbsp;objects that have actually been modified since the last replication between both the&nbsp;containers in question.<br>
<br>
After replication commit, all modified objects (INCLUDING THE ONES THAT WERE NOT&nbsp;REPLICATED) are considered to be "in sync" and will not show up in future&nbsp;"where modified" queries, unless they are modified again.<br>
<br>
<ul>
<a name="outline565"></a><br><h2>20.1. Under the Hood</h2><br>
Let's take a look at the necessary configuration calls to tell db4o to generate&nbsp;version numbers and UUIDs:<br>
<br>
(1) An object's version number indicates the last time an object was modified. It is the&nbsp;database version at the moment of the modification. The database version starts at zero&nbsp;and is incremented every time a transaction is commited.<br>
<br>
(2) UUIDs are object IDs that are unique across all databases created with&nbsp;db4o. That is achieved by having the database's creation timestamp as part&nbsp;of its objects' UUIDs. Manually copying db4o database files can produce duplicate&nbsp;UUIDs, of course.<br>
<br>
When the replication process is commited, the lowest database version number among both&nbsp;databases is set to be equal to the highest. After replication commit, therefore, both&nbsp;databases have the same version number and are "in sync".<br>
<br>
<a name="ReplicatingExisting"></a><br>
<a name="outline566"></a><br><h2>20.2. Replicating Existing Data Files</h2><br>
As we learned in the last sections, Db4o.configure().generateUUIDs() and&nbsp;Db4o.configure().generateVersionNumbers()&nbsp;&nbsp;(or its objectClass counterparts)&nbsp;must be called before storing any objects to a data file because db4o replication needs&nbsp;object versions and UUIDs to work. This implies that objects in existing data files&nbsp;stored without the correct settings can't be replicated.<br>
<br>
Fortunately enabling replication for existing data files is a very simple process: <br>
We just need to use the Defragment tool in com.db4o.tools (source code only) after&nbsp;enabling replication:<br>
<br>
<table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td class="lg">
<code>Db4o.configure().objectClass(Task.class).enableReplication(true); <br>
 new Defragment().run(currentFileName(), true);</code></td></tr></table>
<br>
			<br>
After a successful defragmentation our data files are ready for replication.<br><br><br><small>--<br>generated by </small><a href="http://www.db4objects.com/doctor/" target=_top><small>Doctor</small></a><small> courtesy of </small><a href="http://www.db4objects.com" target=_top><small>db4objects Inc.</small></a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></td></tr></table></div></body></html>