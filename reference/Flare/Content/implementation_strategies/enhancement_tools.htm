<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="6" MadCap:lastHeight="891" MadCap:lastWidth="463" MadCap:ignoredWords="RandomAccessFileAdapter;randomAccessFileAdapter;NonFlushingIoAdapter;nonFlushingIoAdapter;CachedIoAdapter;cachedIoAdapter;disableCommitRecovery;DisableCommitRecovery;extObjectContainer;setSemaphore;getName;SetSemaphore;typeof;LOCK_;getID;GetID;getPilot;getSignature;idenity;car1;car2;car3;UUID;defragment;startsWith;getPoints;StartsWith;ExtentType;oql;AllPilots;OQLQuery;persistenceManager;newQuery;IList;IComparer;ObjectSet;IObjectSet;comparer;ExtObjectContainer;IExtObjectContainer;VB;pilot1;name1;name2;peekPersisted;isCached;JDO;WeakReferences;VM;ClientConfiguration;IClientConfiguration;BatchMessages;NO_OF_OBJECTS;maxBatchQueueSize;MaxBatchQueueSize;listResult;MessageRecipient;ObjectServer;openServer;ObjectNotStorableException;s;clientserverJava;ServerConfiguration;clientserverCS;cs;clientserverVB;vb;config;databaseFileName;int;NativeSocketFactory;socketFactory;OpenClient;hostName;IObjectServer;OpenServer;IConfiguration;INativeSocketFactory;IObjectContainer;genkey;SSLcert;storepass;SecureSocketFactory;IMessageSender;setMessageRecipient;SetMessageRecipient;IMessageRecipient;processMessage;ProcessMessage;ByVal;UpdateServer;waitMilliSeconds;releaseSemaphore;ReleaseSemaphore;monitorObject;semaphoreName;switchToFile;fileName;SwitchToFile;switchToMainFile;SwitchToMainFile;switchs;isAlive;IsAlive;replicateDeletions;ReplicateDeletions;GetType;g;ReplicationEvent;VersionNumbers;providerA;objectsChangedSinceLastReplication;ProviderA;ObjectsChangedSinceLastReplication;hbm;ProviderSignature;MySignature;PeerSignature;ReplicationProvider;HibernateReplicationProvider;ReplicationProviders;m;typed_id;pi2763;longPart;ObjectReference;className;typedId;Uuid;uuid;drs_providers;is_my_sig;t';f';drs_history;provider_id;PK;drs_objects;class_name;varchar;one_to_one;ReplicationConfigurator;SessionFactory;sessionFactory;buildSessionFactory;openSession;beginTransaction;createCriteria;AbstractDb4oTestCase;Db4oFixture;_fixture;AbstractSoloDb4oFixture;AbstractClientServerDb4oFixture;IDb4oFixture;IQuery;NewQuery;retrieveOnlyInstance;RetrieveOnlyInstance;countOccurences;CountOccurences;foreach;Visitor4;Foreach;IVisitor4;obj;deleteAll;DeleteAll;ReflectClass;reflectClass;indexField;fieldName;IndexField;Config;setUp;SetUp;db4oSetupBeforeStore;db4oSetupAfterStore;Db4oSetupBeforeStore;Db4oSetupAfterStore;runSoloAndClientServer;RunSoloAndClientServer;runSolo;RunSolo;runClientServer;RunClientServer;CodeBlock;Db4oUnit;ICodeBlock;isTrue;msg;IsTrue;bool;Msg;areEqual;AreEqual;FrameworkTestCase;runTestAndExpect;expFailures;RunTestAndExpect;ITest;GetConfig;storedType;runtimeType;tAlias;resolveRuntimeName;resolveStoredName;storedPattern;runtimePattern;aliasing;QueryStarted;QueryFinished;QueryEventArgs;ObjectEventArgs;CancellableObjectEventArgs;CommitEventArgs;client2;client1;WaitForCompletion;args;AddHandler;forObjectContainer;ForObjectContainer;OnCreated;createdEvent;onEvent;Event4;ABC0001DEF;MustInherit;CountedObject;IncrementedId;queryStarted;queryFinished;QueryStats;q;executionTime;activationCount;storedClass;Foo;classname;storedClasses;StoredClasses;getStoredFields;GetStoredFields;storedField;getParentStoredClass;GetParentStoredClass;reflectWith;Db4oFactory;ReflectWith;self_get;self_set;LoggingReflector;IoAdapter;MyEncryptionAdapter;Io">
    <head><title>Enhancement Tools	<link href="../Resources/Stylesheets/prettify.css" type="text/css" rel="stylesheet" /><script type="text/javascript" src="../Resources/Code/prettify.js"></script></title>
    </head>
    <body onload="prettyPrint()">
        <h1>
            <MadCap:keyword term="Enhancement" />Enhancement Tools</h1>
        <p>Enhancement tools provide a convenient framework for application (jar, dll, exe) or classes modification to support db4o-specific functionality. Enhancement tools can work on a ready application or library and apply the improvements at load or build time.  </p>
        <p>The tools functionality is provided through bytecode Instrumentation (BI). Bytecode instrumentation  is a process of inserting of special, usually
short, sequences of bytecode at designated points of Java or .NET class. BI is
typically used for profiling or monitoring, however the range of use of
bytecode instrumentation is not limited by this tasks: BI can be applied
anywhere where a specific functionality should be plugged into the ready built
classes.</p>
        <p>db4o Enhamncement Tools currently have 2 usecases for bytecode instrumentation:</p>
        <ul>
            <li><a href="../tuning/native_query_optimization.htm">Native Query Optimization</a>;</li>
            <li><a href="../object_lifecycle/activation/transparent_activation_framework.htm">Transparent
Activation</a>
            </li>
            <li><a href="../object_lifecycle/transparent_persistence.htm">Transparent Persistence</a>
            </li>
        </ul>
        <p>In NQ optimization case bytecode
instrumentation is used as a more performant alternative to a run-time
optimization. When an NQ is optimized the user and compiler-friendly syntax of
NQ predicate is replaced with a query-processor-friendly code (bytecode in the
case of BI). Obviously, optimization process can take some time, therefore it
can be a good choice to use pre-instrumented classes, then to let the
optimization be executed each time it is required by application.</p>
        <p>In TA case, classes are required
to implement Activatable interface to support transparent activation. In many
cases you won't want to "pollute" your proprietary classes with some additional
interface, or even won't be able to do so if you use a third party classes
library. That's where BI comes handy: Activatable interface will be implemented
on your existing classes by applying bytecode instrumentation. Another
advantage of this approach - you can still work on your "clean" classes, just
do not forget to run BI afterwards.</p>
        <p MadCap:conditions="Primary.Java,Primary.All languages">
            <p>Bytecode
instrumentation in Java can be run at build time (also known as static
instrumentation). In this case a special (build) script calls BI on the classes
before packaging them to jar, or on the jar itself (classes are extracted,
instrumented and jarred again). This is the fastest solution as no time is
spent on bytecode instrumentation at runtime. </p>
            <p>Another method is to use BI at load time. In this case
instrumenting information is inserted into the classes by a specific
instrumenting classloader just before they are loaded into the VM.</p>
        </p>
        <p>The following topics discuss BI implementation for db4o
needs in more detail and explain the tools and API that should be used for BI
tasks.</p>
        <ul>
            <li MadCap:conditions="Primary.Java"><a href="enhancement_tools/enhancement_for_java.htm">Enhancement For Java</a>
            </li>
            <p MadCap:conditions="Primary:java" />
            <li MadCap:conditions="Primary..NET"><a href="enhancement_tools/enhancement_for_.net.htm">Enhancement For .NET</a>
            </li>
            <p MadCap:conditions="Primary:net" />
        </ul>
    </body>
</html>