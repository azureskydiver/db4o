<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="6" MadCap:lastHeight="2958" MadCap:lastWidth="1029">
<head><title>Data Persistence	<link href="../Resources/Stylesheets/prettify.css" type="text/css" rel="stylesheet" />		<script type="text/javascript" src="../Resources/Code/prettify.js"></script></title></head>
<body onload="prettyPrint()">
    <div class="CommonContent">
      <div class="CommonContentArea">
        <h1>Data Persistence</h1>

<p>Software programs using different data
persistence technologies are an integral part of contemporary informational
space. More than often such systems are implemented with the help of
object-oriented programming language (Java, c#, etc.) and a relational database
management system (Oracle, MySQL, etc.). This implementation originally
contains a mismatch between relational and object worlds, which is often called
"object/relational impedance mismatch" (OR mismatch shortly). The
essence of the problem is in the way the systems are designed. Object systems
consist of objects and are characterized by identity, state, behavior,
encapsulation. The relational model consists of tables, columns, rows and
foreign keys and is described by relation, attribute, tuple, relation value and
relation variable.</p>

<p>The object-relational mismatch has become
enormously significant with the total adoption of OO technology. This resulted
in the rapid development of so-called object-relational mappers (ORM), such as
Hibernate or Toplink. This solution "cures" the symptoms of the OR
mismatch by adding a layer into the software stack that automates the tedious
task of linking objects to tables. However, this approach creates a huge drain
on system performance, drives up software complexity, and increases the burden
on software maintenance, thus resulting in higher cost of ownership. While the
mapper solution may be feasible in large, administered datacenter environments,
it is prohibitive in distributed and zero-administration architectures such as
those required for embedded databases in client software, mobile devices,
middleware or real-time systems.</p>

<p>Significant
side effects of the object relational mismatch manifest themselves in
unnecessary system overhead with bloated footprints and runtime performance
issues.  Of course, there is also overall
time to market delays due to poor developer productivity.   The overhead still exists in ORM because
under the covers, the runtime is still query driven.  And, despite improvements in productivity for
developers, incremental changes to your object models reek havoc during ORM schema
evolution pitfalls.  The more complicated
your models are, the more problematic keeping changes in sync with the internal
mapping.</p>



<p>Primary
performance issues come from the fact that despite being called a "relational
database", an RDBMS does not store direct relations.   Relations are resolved at runtime by
performing set based operations on primary-foreign key pairs.   This
means the application has to constantly re-discover data relationships at
runtime resulting in immense CPU consumption for something that should be an
inherent part of your application model. 
Further, because discovering these relations over and over again
requires continual access to index structures and data to perform the set
operations, contention is much higher within database internals leading to poor
scalability of individual database processes. </p>



<p>Further,
lack of direct storage of relations cause the application design to become
query driven instead of object modeling driven. 
Using an object database, the relations are a fundamental part of the
storage architecture. So, application design is model driven.  You do not have to suffer any performance
overhead for discovering an M-M relationship. The relationships are just there
and immediately accessible to the requesting thread.  This makes the internal structures much
simpler and therefore less contention exists with data requests being isolated
to data of interest instead of leveraging indexes or sequential scans.  The result, individual processes become more
scalable under concurrency. </p>



<p>Technology
is ever changing and today there is a whole world of object database experts in
the software community.  Anyone who is an
expert in ORM technology is an expert in object database technology.  All of the concepts found in object life cycle
management within ORM technologies were invented by the object database
community in the early 90's.  All of the
tuning concepts of closure, fetch configurations, first class -vs- second class
objects, light weight transactions - are concepts created by and applicable to object database
technologies.  Now with the growing
popularity of object based design and the proliferation of ORM tools, thousands
of developers are becoming experts in the object database API.</p>

</div>
    </div>
    
  </body></html>
