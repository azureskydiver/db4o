<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="6" MadCap:lastHeight="2958" MadCap:lastWidth="1029">
<head><title>Native Query Optimization	<link href="../Resources/Stylesheets/prettify.css" type="text/css" rel="stylesheet" />		<script type="text/javascript" src="../Resources/Code/prettify.js"></script></title></head>
<body onload="prettyPrint()">
    <div class="CommonContent">
      <div class="CommonContentArea">
        <h1>Native Query Optimization</h1><div id="TOC"><div id="TOCinner"><span class="TOCtitle">Contents</span><div class="TOCcontents"><ul><li><a href ="#Optimization Theory ">Optimization Theory </a></li><li><a href ="#NQ Optimization For Java">NQ Optimization For Java</a></li><li><a href ="#NQ Optimization for .NET">NQ Optimization for .NET</a></li></ul></li></ul></div></div></div> 

<P>Native Queries will run out of the box in any environment. If optimization is turned on (default) Native Queries will be converted to <a href="../object_lifecycle/querying/soda_query.html" class="wikiLink">SODA</a> where this is possible, allowing db4o to use indexes and optimized internal comparison algorithms.Otherwise Native Query may be executed by instantiating all objects, using <a href="../object_lifecycle/querying/soda_evaluations.html" class="wikiLink">SODA Evaluations</a>. Naturally performance will not be as good in this case.</P>
<a name="Optimization Theory "></a><H2>Optimization Theory </H2>

<P>For Native Query Java bytecode and .NET IL code are analyzed to create an AST-like expression tree. Then the flow graph of the expression tree is analyzed and converted to a SODA query graph.</P>
<P>For example:</P>
<p MadCap:conditions="Primary.Java">
<P>Java: </P>
<P><code>List&lt;Pilot&gt; pilots = container.query(new Predicate&lt;Pilot&gt;() {</code></P>
<P><code>                                                public boolean match(Pilot pilot) {</code></P>
<P><code>                                                            return pilot.getName().equals("Michael Schumacher")</code></P>
<P><code>&amp;&amp; pilot.getPoints() == 100;</code></P>
<P><code>                                                }</code></P>
<P><code>                                    });</code></P>
</p><p MadCap:conditions="Primary:java" />
<p MadCap:conditions="Primary.Print">
<P>.NET: </P>
<P><code>IList&lt;Pilot&gt; pilots = container.Query&lt;Pilot&gt;(delegate(Pilot pilot) {</code></P>
<P><code>                                                            return pilot.Name.equals("Michael Schumacher")</code></P>
<P><code>&amp;&amp; pilot.Points == 100;</code></P>
<P><code>                                    });</code></P>
</p><p MadCap:conditions="Primary:net" />
<P>First of all the following code will be extracted:</P>
<P>query#constrain(Pilot)</P>
<P>Then a more complex analysis will be run to convert the contents of the #match method into a SODA-understandable syntax. On a simple example it is easy to see what will happen:</P>
<p MadCap:conditions="Primary.Java">
<P>Java: </P>
<P><code>return pilot.getName().equals("Michael Schumacher") &amp;&amp; pilot.getPoints() == 100;</code></P>
</p><p MadCap:conditions="Primary:java" />
<p MadCap:conditions="Primary.Print">
<P>.NET:</P>
<P><code>return pilot.Name.equals("Michael Schumacher") &amp;&amp; pilot.Points == 100;</code></P>
</p><p MadCap:conditions="Primary:net" />
<P>easily converts into:</P>
<P><code>CANDIDATE.name == "Michael Schumacher"</code></P>
<P><code>CANDIDATE.points == 100</code></P>
<p MadCap:conditions="Primary.Java">
<a name="NQ Optimization For Java"></a><H2>NQ Optimization For Java</H2>
<P>NQ optimisation on Java requires db4onqopt.jar and bloat.jar to be present in the CLASSPATH.<BR><BR>The Native Query optimizer is still under development to eventually "understand" all Java constructs. Current optimization supports the following constructs well:</P>
<UL>
<LI>compile-time constants</LI>
<LI>simple member access</LI>
<LI>primitive comparisons</LI>
<LI>#equals() on primitive wrappers and Strings</LI>
<LI>#contains()/#startsWith()/#endsWith() for Strings</LI>
<LI>arithmetic expressions</LI>
<LI>boolean expressions</LI>
<LI>static field access</LI>
<LI>array access for static/predicate fields</LI>
<LI>arbitrary method calls on static/predicate fields (without candidate based params)</LI>
<LI>candidate methods composed of the above</LI>
<LI>chained combinations of the above<BR></LI></UL>
<P>This list will constantly grow with the latest versions of db4o.</P>
<P>Note that the current implementation doesn't support polymorphism and multiline methods yet.</P>
<P>db4o for Java supplies three different possibilities to run optimized native queries, optimization at</P>
<OL>
<LI><a href="native_query_optimization/optimization_at_query_execution_time.html" class="wikiLink">query execution time</a></LI>
<LI><a href="../object_lifecycle/activation/transparent_activation_framework/ta_enhanced_example/ta_enhancement_at_build_time.html" class="wikiLink">deployment time</a></LI>
<LI><a href="../object_lifecycle/activation/transparent_activation_framework/ta_enhanced_example/ta_enhancement_at_load_time.html" class="wikiLink">class loading time</a></LI></OL>
</p><p MadCap:conditions="Primary:java" />
<p MadCap:conditions="Primary.Print">
<a name="NQ Optimization for .NET"></a><H2>NQ Optimization for .NET</H2>
<P>Native Query optimizer for .NET requires the following libraries to work:</P>
<UL>
<LI><SPAN id=ctl00_ctl00_bcr_topicView___TopicBody><SPAN class=net>Db4obects.Db4o.Instrumentation.dll</SPAN></SPAN></LI>
<LI><SPAN><SPAN class=net>Db4objects.Db4o.NativeQueries.dll</SPAN></SPAN></LI>
<LI><SPAN><SPAN class=net>Mono.Cecil.dll</SPAN></SPAN></LI>
<LI><SPAN><SPAN class=net>Cecil.FlowAnalysis.dll</SPAN></SPAN></LI></UL>
<P><SPAN><SPAN class=net> These assemblies must be available in your project for successful NQ optimization.<BR></P></SPAN></SPAN>
<P>The Native Query optimizer is still under development to eventually "understand" all valid C# constructs. Current optimization supports the following constructs well:</P>
<UL>
<LI>compile-time constants</LI>
<LI>simple member access</LI>
<LI>primitive comparisons</LI>
<LI>equality operator</LI>
<LI>#Contains()/#StartsWith()/#EndsWith() for Strings</LI>
<LI>boolean expressions</LI>
<LI>arbitrary method calls (including property accessors) on predicate fields (without any arguments)</LI>
<LI>candidate methods composed of the above</LI>
<LI>chained combinations of the above<BR></LI></UL>
<P>This list will constantly grow with the latest versions of db4o.</P>
<P>Note that the current implementation doesn't support polymorphism yet.</P>
<P>The specifics of Compact Framework platform are explained in <a href="native_query_optimization/nq_optimization_on_cf2.0.html" class="wikiLink">NQ Optimization On CF2.0</a>. </P>
<P>An alternative optimization practice can be found in <a href="native_query_optimization/build-time_optimization_for_.net.html" class="wikiLink">Build-time Optimization For .NET</a> article.<BR></P>
</p><p MadCap:conditions="Primary:net" />
<P>For more information on NQ optimization see <a href="native_query_optimization/monitoring_optimization.html" class="wikiLink">Monitoring Optimization</a>.<BR></P></div>
    </div>
    
  </body></html>
