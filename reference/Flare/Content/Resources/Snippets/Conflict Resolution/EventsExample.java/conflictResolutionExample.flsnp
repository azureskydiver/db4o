<?xml version="1.0" encoding="utf-8"?> <html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="2" MadCap:lastHeight="309" MadCap:lastWidth="1029">    <head>    </head>    <body>        <pre class="prettyprint" xml:space="preserve">EventsExample.java: conflictResolutionExample
private static void conflictResolutionExample() ...{
    Configuration config = Db4o.newConfiguration();
    config.generateUUIDs(ConfigScope.GLOBALLY);
    config.generateVersionNumbers(ConfigScope.GLOBALLY);

    //  Open databases
    ObjectContainer desktop = Db4o.openFile(config, &quot;desktop.db4o&quot;);
    ObjectContainer handheld = Db4o.openFile(config, &quot;handheld.db4o&quot;);

    Pilot pilot = new Pilot(&quot;Scott Felton&quot;, 200);
    handheld.store(pilot);
    handheld.commit();
    /**//* Clean the reference cache to make sure that objects in memory
    * won't interfere
    */ 
    handheld.ext().refresh(Pilot.class, Integer.MAX_VALUE);
    
    /**//* Replicate changes from handheld to desktop
     * Note, that only objects replicated from one database to another will 
     * be treated as the same. If you will create an object and save it to both
     * databases, dRS will count them as 2 different objects with identical 
     * fields.
     */
    ReplicationSession replication = Replication.begin(handheld, desktop);
    ObjectSet changedObjects = replication.providerA().objectsChangedSinceLastReplication();
    while (changedObjects.hasNext())
      replication.replicate(changedObjects.next());
    replication.commit();
    
    // change object on the handheld
    pilot = (Pilot)handheld.query(Pilot.class).next();
    pilot.setName(&quot;S.Felton&quot;);
    handheld.store(pilot);
    handheld.commit();
    
    //  change object on the desktop
    pilot = (Pilot)desktop.query(Pilot.class).next();
    pilot.setName(&quot;Scott&quot;);
    desktop.store(pilot);
    desktop.commit();
    
    /**//* The replication will face a conflict: Pilot object was changed on the 
    * handheld and on the desktop.
    * To resolve this conflict we will add an event handler, which makes
    * desktop changes dominating.
    */
    ReplicationEventListener listener;
    listener = new ReplicationEventListener() ...{
      public void onReplicate(ReplicationEvent event) ...{
        if (event.isConflict()) ...{
          ObjectState chosenObjectState = event.stateInProviderB();
          event.overrideWith(chosenObjectState);
        }
      }
    };

    replication = Replication.begin(handheld, desktop, listener);

    //The state of the desktop after the replication should not change, as it dominates
    changedObjects = replication.providerA().objectsChangedSinceLastReplication();
    while (changedObjects.hasNext())
      replication.replicate(changedObjects.next());

    //Commit
    replication.commit();
    replication.close();
    
    // Check what we've got on the desktop
    ObjectSet result = desktop.query(Pilot.class);
    System.out.println(result.size());
    while (result.hasNext()) ...{
      System.out.println(result.next());
    }
    handheld.close();
    desktop.close();
    
    new File(&quot;handheld.db4o&quot;).delete();
    new File(&quot;desktop.db4o&quot;).delete();

  }</pre>    </body></html>