<?xml version="1.0" encoding="utf-8"?> <html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="2" MadCap:lastHeight="309" MadCap:lastWidth="1029">    <head>    </head>    <body>        <pre class="prettyprint" xml:space="preserve">StartServer.java
1/**//* Copyright (C) 2007 Versant Inc. http://www.db4o.com */
2package com.db4odoc.clientserver;
3
4import com.db4o.ObjectContainer;
5import com.db4o.ObjectServer;
6import com.db4o.cs.Db4oClientServer;
7import com.db4o.cs.config.ServerConfiguration;
8import com.db4o.messaging.MessageContext;
9import com.db4o.messaging.MessageRecipient;
0
1/** *//**
2 * starts a db4o server with the settings from {@link ServerSetup}. &lt;br&gt;
3 * &lt;br&gt;
4 * This is a typical setup for a long running server. &lt;br&gt;
5 * &lt;br&gt;
6 * The Server may be stopped from a remote location by running StopServer. The
7 * StartServer instance is used as a MessageRecipient and reacts to receiving an
8 * instance of a StopServer object. &lt;br&gt;
9 * &lt;br&gt;
0 * Note that all user classes need to be present on the server side and that all
1 * possible Db4oEmbedded.configure() calls to alter the db4o configuration need
2 * to be executed on the client and on the server.
3 */
4public class StartServer implements ServerSetup, MessageRecipient  {
5
6  /** *//**
7   * setting the value to true denotes that the server should be closed
8   */
9  private boolean stop = false;
0
1  /** *//**
2   * starts a db4o server using the configuration from
3   * {@link ServerSetup}.
4   */
5  public static void main(String[] arguments)  {
6    new StartServer().runServer();
7  }
8
9  // end main
0
1  /** *//**
2   * opens the ObjectServer, and waits forever until close() is called or a
3   * StopServer message is being received.
4   */
5  public void runServer()  {
6    synchronized (this)  {
7      // Using the messaging functionality to redirect all
8      // messages to this.processMessage
9      ServerConfiguration config = Db4oClientServer.newServerConfiguration();
0      config.networking().messageRecipient(this);
1
2      ObjectServer db4oServer = Db4oClientServer.openServer(
3          config, FILE, PORT);
4      db4oServer.grantAccess(USER, PASS);
5
6      
7      // to identify the thread in a debugger
8      Thread.currentThread().setName(this.getClass().getName());
9
0      // We only need low priority since the db4o server has
1      // it's own thread.
2      Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
3      try  {
4        if (!stop)  {
5          // wait forever for notify() from close()
6          this.wait(Long.MAX_VALUE);
7        }
8      } catch (Exception e)  {
9        e.printStackTrace();
0      }
1      db4oServer.close();
2    }
3  }
4
5  // end runServer
6
7  /** *//**
8   * messaging callback
9   * 
0   * @see com.db4o.messaging.MessageRecipient#processMessage(ObjectContainer,
1   *      Object)
2   */
3  public void processMessage(MessageContext context, Object message)  {
4    if (message instanceof StopServer)  {
5      close();
6    }
7  }
8
9  // end processMessage
0
1  /** *//**
2   * closes this server.
3   */
4  public void close()  {
5    synchronized (this)  {
6      stop = true;
7      this.notify();
8    }
9  }
0  // end close
1}</pre>    </body></html>