<?xml version="1.0" encoding="utf-8"?> <html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="2" MadCap:lastHeight="309" MadCap:lastWidth="1029">    <head>    </head>    <body>        <pre class="prettyprint" xml:space="preserve">UpdatePerformanceBenchmark.java: Item
private void update(Object item)  {
      objectContainer.store(item);
  }
    // end update
  
    
    private void runDifferentObjectsTest() {
      System.out.println(&quot;Update test with different objects&quot;);
      int objectsToUpdate = 90;
      int updated = objectsToUpdate;
          
      initDifferentObjectsTest();
      
      clean();
      System.out.println(&quot; - primitive object with int field&quot;);
      open(configure());
      storeSimplest();
      
    ObjectSet result = objectContainer.queryByExample(null);
    startTimer();
    for (int i = 0; i &lt; objectsToUpdate; i ++) {
      if (result.hasNext()) {
        SimplestItem item = (SimplestItem)result.next();
        item._id = 1;
          update(item);  
      } else  {
        updated = i;
        break;
      }
    }
      stopTimer(&quot;Updated &quot; + updated + &quot; items&quot;);
      close();
    
      clean();
      open(configure());
      System.out.println(&quot; - object with String field&quot;);
      store();
      updated = objectsToUpdate;
      result = objectContainer.queryByExample(null);
      startTimer();
      for (int i = 0; i &lt; objectsToUpdate; i ++) {
      if (result.hasNext()) {
        Item item = (Item)result.next();
        item._name = &quot;Updated&quot;;
          update(item);  
      } else  {
        updated = i;
        break;
      }
    }
      stopTimer(&quot;Updated &quot; + updated + &quot; items&quot;);
      close();
      
      clean();
      open(configure());
      System.out.println(&quot; - object with StringBuffer field&quot;);
      storeWithStringBuffer();
      
      updated = objectsToUpdate;
      result = objectContainer.queryByExample(null);
      startTimer();
      for (int i = 0; i &lt; objectsToUpdate; i ++) {
      if (result.hasNext()) {
        ItemWithStringBuffer item = (ItemWithStringBuffer)result.next();
        item._name = new StringBuffer(&quot;Updated&quot;);
          update(item);  
      } else  {
        updated = i;
        break;
      }
    }
      stopTimer(&quot;Updated &quot; + updated + &quot; items&quot;);
      close();
      
      clean();
      open(configure());
      System.out.println(&quot; - object with int array field&quot;);
      storeWithArray();
      updated = objectsToUpdate;
      result = objectContainer.queryByExample(null);
      startTimer();
      for (int i = 0; i &lt; objectsToUpdate; i ++) {
      if (result.hasNext()) {
        ItemWithArray item = (ItemWithArray)result.next();
        item._id = new int[] {1,2,3};
          update(item);  
      } else  {
        updated = i;
        break;
      }
    }
      stopTimer(&quot;Updated &quot; + updated + &quot; items&quot;);
      close();
      
      clean();
      open(configure());
      System.out.println(&quot; - object with ArrayList field&quot;);
      storeWithArrayList();
      updated = objectsToUpdate;
      result = objectContainer.queryByExample(null);
      startTimer();
      for (int i = 0; i &lt; objectsToUpdate; i ++) {
      if (result.hasNext()) {
        ItemWithArrayList item = (ItemWithArrayList)result.next();
        item._ids = new ArrayList();
          update(item);  
      } else  {
        updated = i;
        break;
      }
    }
      stopTimer(&quot;Updated &quot; + updated + &quot; items&quot;);
      close();
    }
    // end runDifferentObjectsTest
    
    private void runIndexTest() {
      System.out.println(&quot;Update test for objects with and without indexed fields&quot;);
          
      int objectsToUpdate = 100;
      init();
      System.out.println(&quot;Updating &quot; + objectsToUpdate + &quot; of &quot; + _count + &quot; objects&quot;);
      clean();
      open(configure());
      store();
      updateItems(objectsToUpdate);
      close();
      
      clean();
      init();
      System.out.println(&quot;Updating &quot; + objectsToUpdate + &quot; of &quot; + _count + &quot; objects with indexed field&quot;);
      open(configureIndexTest());
      store();
      updateItems(objectsToUpdate);
      close();
    }
    // end runIndexTest

    
    private void init() {
      _count = 1000;
        _depth = 90;
        _isClientServer = false;
          
    }
    // end init
    
    private void initDifferentObjectsTest() {
      _count = 1000;
        _depth = 1;
        _isClientServer = false;
          
    }
    // end initDifferentObjectsTest
    

    
    private void initForClientServer() {
      _count = 1000;
        _depth = 90;
        _isClientServer = true;
        _host = &quot;localhost&quot;;  
    }
    // end initForClientServer
    
    private void initForRamDriveTest() {
      _count = 30000;
        _depth = 1;
        _filePath = &quot;r:\\performance.db4o&quot;;
        _isClientServer = false;
          
    }
    // end initForRamDriveTest
    
    private void initForHardDriveTest() {
      _count = 10000;
        _depth = 3;
        _filePath = &quot;performance.db4o&quot;;
        _isClientServer = false;
    }
    // end initForHardDriveTest
    
    private void initForCommitTest() {
      _count = 10000;
      _commitInterval = 1000;
        _depth = 3;
        _isClientServer = false;
    }
    // end initForCommitTest
    
    private void clean() {
      new File(_filePath).delete();
    }
    // end clean
    
    private Configuration configure() {
      Configuration config = Db4o.newConfiguration();
      // using MemoryIoAdapter improves the performance 
      // by replacing the costly disk IO operations with 
      // memory access
        config.io(new MemoryIoAdapter());
        return config;
    }
    // end configure

    private Configuration configureTP() {
      Configuration config = Db4o.newConfiguration();
      // With Transparent Persistence enabled only modified
      // objects are written to disk. This allows to achieve 
      // better performance
        config.objectClass(Item.class).cascadeOnUpdate(true);
      return config;
    }
    // end configureTP

    private Configuration configureCascade() {
      Configuration config = Db4o.newConfiguration(); 
      // CascadeOnUpdate can be a performance-killer for 
      // deep object hierarchies
        config.objectClass(Item.class).cascadeOnUpdate(true);
        return config;
    }
    // end configureCascade

    private Configuration configureIndexTest() {
      Configuration config = Db4o.newConfiguration(); 
        config.io(new MemoryIoAdapter());
        config.objectClass(Item.class).objectField(&quot;_name&quot;).indexed(true);
        return config;
    }
    // end configureIndexTest
    
    private Configuration configureForCommitTest() {
      Configuration config = Db4o.newConfiguration(); 
        config.lockDatabaseFile(false);
        // the commit information is physically written 
        // and in the correct order
        config.flushFileBuffers(true);
        return config;
    }
    // end configureForCommitTest


    private Configuration configureClientServer() {
      Configuration config = Db4o.newConfiguration(); 
        config.clientServer().singleThreadedClient(true);
        return config;
    }
    // end configureClientServer

    private Configuration configureDriveTest() {
      Configuration config = Db4o.newConfiguration(); 
        config.flushFileBuffers(true);
        return config;
    }
    // end configureDriveTest
    
    private void store() {
        startTimer();
        for (int i = 0; i &lt; _count ;i++)  {
            Item item = new Item(&quot;level&quot; + i, null);
            for (int j = 1; j &lt; _depth; j++)  {
                item = new Item(&quot;level&quot; + i + &quot;/&quot; + j, item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end store

    private void storeActivatableItems() {
        startTimer();
        for (int i = 0; i &lt; _count ;i++)  {
            ActivatableItem item = new ActivatableItem(&quot;level&quot; + i, null);
            for (int j = 1; j &lt; _depth; j++)  {
                item = new ActivatableItem(&quot;level&quot; + i + &quot;/&quot; + j, item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end storeActivatableItems

    private void storeInherited() {
        startTimer();
        for (int i = 0; i &lt; _count ;i++)  {
            ItemDerived item = new ItemDerived(&quot;level&quot; + i, null);
            for (int j = 1; j &lt; _depth; j++)  {
                item = new ItemDerived(&quot;level&quot; + i + &quot;/&quot; + j, item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end storeInherited

    
    private void storeWithStringBuffer() {
        startTimer();
        for (int i = 0; i &lt; _count ;i++)  {
            ItemWithStringBuffer item = new ItemWithStringBuffer(new StringBuffer(&quot;level&quot; + i), null);
            for (int j = 1; j &lt; _depth; j++)  {
                item = new ItemWithStringBuffer(new StringBuffer(&quot;level&quot; + i + &quot;/&quot; + j), item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end storeWithStringBuffer
    
    private void storeSimplest() {
        startTimer();
        for (int i = 0; i &lt; _count ;i++)  {
          SimplestItem item = new SimplestItem(i, null);
            for (int j = 1; j &lt; _depth; j++)  {
                item = new SimplestItem(i, item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end storeSimplest
    
    private void storeWithArray() {
        startTimer();
        int[] array = new int[] {1,2,3,4};
        for (int i = 0; i &lt; _count ;i++)  {
          int[] id = new int[] {1,2,3,4};
          ItemWithArray item = new ItemWithArray(id, null);
            for (int j = 1; j &lt; _depth; j++)  {
              int[] id1 = new int[] {1,2,3,4};
                item = new ItemWithArray(id1, item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end storeWithArray
    
    private void storeWithArrayList() {
      startTimer();
      ArrayList idList = new ArrayList();
      idList.add(1);
      idList.add(2);
      idList.add(3);
      idList.add(4);
        for (int i = 0; i &lt; _count ;i++)  {
          ArrayList ids = new ArrayList();
          ids.addAll(idList);
          ItemWithArrayList item = new ItemWithArrayList(ids, null);
            for (int j = 1; j &lt; _depth; j++)  {
              ArrayList ids1 = new ArrayList();
              ids1.addAll(idList);
              item = new ItemWithArrayList(ids1, item);
            }
            objectContainer.store(item);
        }
        objectContainer.commit();
        stopTimer(&quot;Store &quot;+ totalObjects() + &quot; objects&quot;);
    }
    // end storeWithArrayList
    
    private int totalObjects() {
      return _count * _depth;
    }
    // end totalObjects
    
    private void open(Configuration config) {
        if(_isClientServer) {
          int port = TCP ? PORT : 0;
          String user = &quot;db4o&quot;;
          String password = user;
            objectServer = Db4o.openServer(_filePath, port);
            objectServer.grantAccess(user, password);
            objectContainer = TCP ? Db4o.openClient(_host, port, user,
          password) : objectServer.openClient();
        } else {
            objectContainer = Db4o.openFile(config, _filePath);
        }
    }
    // end open
    
    private void close() {
        objectContainer.close();
        if(_isClientServer) {
            objectServer.close();
        }
    }
    //end close
    
    private void startTimer() {
      startTime = System.currentTimeMillis();
    }
    // end startTimer

    
    private void stopTimer(String message) {
        long stop = System.currentTimeMillis();
        long duration = stop - startTime;
        System.out.println(message + &quot;: &quot; + duration + &quot;ms&quot;);
    }
    // end stopTimer
    
    public static class Item  {

      public String _name;
        public Item _child;

        public Item() {
            
        }
        
        public Item(String name, Item child) {
            _name = name;
            _child = child;
        }
    }</pre>    </body></html>