.n
.a IDs ..
.1 IDs and UUIDs ..

The db4o team recommends not to use object IDs where this is ._
not necessary. db4o keeps track of object identities in a ._
transparent way, by identifying "known" objects on updates. ._
The reference system also makes sure that every persistent ._
object is instantiated only once, when a graph of objects is ._
retrieved from the database, no matter which access path is ._
chosen. If an object is accessed by multiple queries or by ._
multiple navigation access paths, db4o will always return ._
the one single object, helping you to put your object graph together ._
exactly the same way as it was when it was stored, without ._
having to use IDs.

The use of IDs does make sense when object and database are ._
disconnected, for instance in stateless applications.

db4o provides two types of ID systems.

.2 Internal IDs ..
The internal db4o ID is a physical pointer into the database ._
with only one indirection in the file to the actual object ._
so it is the fastest external access to an object db4o provides. ._
The internal ID of an object is available with
.? java  .c objectContainer.ext().getID(object); ..  ..?
.? net  .c objectContainer.Ext().GetID(object); ..  ..?
.? mono  .c objectContainer.Ext().GetID(object); ..  ..?
To get an object for an internal ID use
.? java  .c objectContainer.ext().getByID(id); ..  ..?
.? net  .c objectContainer.Ext().GetByID(id); ..  ..?
.? mono  .c objectContainer.Ext().GetByID(id); ..  ..?
Note that #getByID() does not activate objects. If you want ._
to work with objects that you get with #getByID(), your code ._
would have to make sure the object is  .l Activation activated ..  by calling
.? java  .c objectContainer.activate(object, depth); ..   ..?
.? mono  .c objectContainer.Activate(object, depth); ..   ..?
.? net   .c objectContainer.Activate(object, depth); ..   ..?
db4o assigns internal IDs to any stored first class object. These ._
internal IDs are guaranteed to be unique within one ObjectContainer/ObjectServer and they will stay the same for every ._
object when an ObjectContainer/ObjectServer is closed and reopened. ._
Internal IDs  .b will change ..  when an object is moved from one ._
ObjectContainer to another, as it happens during  .l Defragment ..  .

.2 Unique Universal IDs (UUIDs) ..
For long-term external references and to identify an object even after it has been copied or moved to ._
another ObjectContainer, db4o supplies Unique Universal IDs (UUIDs).

Every newly created db4o database generates a signature object. It is stored as an instance ._
of Db4oDatabase in your database file.
This signature is linked to all newly created objects (if UUID generation is enabled) ._
as the "signature part" of the UUID.
Further to that db4o creates a timestamp for every new object and uses an internal counter ._
to make sure that timestamps are unique. This is called the "long part" of the UUID.
The long part is indexed to make the search fast. If two objects with an identical long parts are ._
found, the signature parts are compared also.
The long part of the UUID can also be used to find out when an object was created. You can use 
.c com.db4o.foundation.TimeStampIdGenerator#idToMilliseconds() ..
to get object creation time in milliseconds.

UUIDs are guaranteed to be unique, if the signature of your db4o database is unique.

Normally any database has a unique signature unless its file is copied. The original ._
and copied database files are identical, so they have the same signatures. If such files are ._
used in replication, the process will end up with exceptions. What is the solution then?
Signature of a database file can be changed using .c YapFile#GenerateNewIdentity ..  method. 
.s com.db4odoc.f1.uuids.UUIDExample#testChangeIdentity ..
UUIDs are not generated by default, since they occupy extra space in the database file and ._
produce performance overhead for maintaining their index. UUIDs can be turned on globally ._
or for individual classes:
.? java  .c Db4o.configure().generateUUIDs(Integer.MAX_VALUE) ..   .. 
.? net  .c Db4o.Configure().GenerateUUIDs(Int32.MaxValue) ..   .. 
.? mono  .c Db4o.Configure().GenerateUUIDs(Int32.MaxValue) ..   .. 
- turns on UUID generation ._
for all classes in a database. 
.? java  .c Db4o.configure().objectClass(Foo.class).generateUUIDs(true) ..   .. 
.? net  .c Db4o.Configure().ObjectClass(typeof(Foo)).GenerateUUIDs(true) ..   .. 
.? mono  .c Db4o.Configure().ObjectClass(typeof(Foo)).GenerateUUIDs(true) ..   .. 
  - turns on UUID generation ._
for a specific class.
You can get the UUID value for an object using the following methods:
.? java  .c ExtObjectContainer#getObjectInfo(Object) ..
.c ObjectInfo#getUUID() ..   ..?
.? net  .c ExtObjectContainer#GetObjectInfo(Object) ..
.c ObjectInfo#GetUUID() ..   ..?
.? mono  .c ExtObjectContainer#GetObjectInfo(Object) ..
.c ObjectInfo#GetUUID() ..   ..?
To get the object from the database, knowing its UUID, use: 
.? java  .c ExtObjectContainer#getByUUID(Db4oUUID) ..  ..?
.? net  .c ExtObjectContainer#GetByUUID(Db4oUUID) ..  ..?
.? mono  .c ExtObjectContainer#GetByUUID(Db4oUUID) ..  ..?
The following example shows the usage of UUID: 
.s com.db4odoc.f1.uuids.UUIDExample#setObjects -out ..
.s com.db4odoc.f1.uuids.UUIDExample#testGenerateUUID ..
Sometimes you can find out that you need UUIDs only when the database is already created ._
and has some data in it. What can you do in that case?
Fortunately enabling replication for existing data files is a very simple process: you just need ._
to use the Defragment tool in com.db4o.tools (source code only) after enabling replication:
.? java  .c Db4o.configure().objectClass(Task.class).enableReplication(true) ..
.c new Defragment().run(currentFileName(), true) ..   ..?
.? net  .c Db4o.Configure().ObjectClass(typeof(Task)).EnableReplication(true) ..
.c new Defragment().Run(currentFileName(), true) ..   ..?
.? mono  .c Db4o.Configure().ObjectClass(typeof(Task)).EnableReplication(true) ..
.c new Defragment().Run(currentFileName(), true) ..   ..?
You can use UUID for replication and as a reference to a specific object instance from an ._
external application or data store.
