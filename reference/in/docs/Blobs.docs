.n
.a Blobs ..
.1 Blobs ..


In some cases user has to deal with large binary objects (BLOBs) such as images, video, music, ._
which should be stored in a structured way, and retrieved/queried easily. There are several challenges ._
associated with this task:

-	storage location;
-	loading into RAM;
-	querying interface;
-	objects' modification;
-	information backup;
-	client/server processing.

Db4o provides you with a flexibility of using 2 different solutions for this case:
1) com.db4o.types.Blob
2) byte[] arrays stored inside the database file


These two solutions' main features in comparison are represented below:

.b com.db4o.types.Blob .. 

1)	every Blob gets it's own file 
2)	C/S communication runs asynchronous in separate thread 
3)	special code is necessary to store and load 
4)	no concerns about activation depth 


.b byte[] array ..

1)	data in the same file 
2)	C/S communication runs in the normal communication thread 
3)	transparent handling without special concerns 
4)	control over activation depth may be necessary


Storing data in a byte[] array works just as storing usual objects, but this method is not always applicable/desirable. ._
First of all, the size of the db4o file can grow over the limit (256 GB) due to the BLOB data added. ._
Secondly, object activation and client/server transferring logic can be an additional load for your ._
application.

.2 db4o Blob implementation ..

Built-in db4o Blob type helps you to get rid of the problems of byte[] array, though it has its own drawbacks. Pros ._
and Cons for the points, mentioned above:

1) 
+ main database file stays a lot smaller 
+ backups are possible over individual files 
+ the BLOBs are accessible without db4o
- multiple files need to be managed 


2) 
+ asynchronous storage allows the main application thread to continue its work, while blobs are ._
being stored 

3) 
- it is more difficult to move objects between db4o database files 
4) 
+ no worries about activation depth

Let's look, how it works. 

First, BLOB storage should be defined:

.c Db4o.configure().setBlobPath(storageFolder); ..

where storageFolder is a String value representing local or server path to store BLOBs. If that value is ._
not defined, db4o will use the default folder "blobs" in user directory.

We will use a modified Car class, which holds reference to the car photo:

.c
public class Car {
    private String model;
    private CarImage img;
    
   
    public Car(String model) {
        this.model=model;
        img=new CarImage();
        img.setFile(model+".jpg");
    }
  
    public CarImage getImage() {
        return img;
    }
    
    public String toString() {
        return model +"(" + img.getFile() + ")" ;
    }
} ..

CarImage is a wrapper to BLOB, representing the photo:

.c import java.io.File;

import com.db4o.ext.Status;
import com.db4o.types.Blob;


public class CarImage {
	Blob blob;
	private String fileName = null;
	private String inFolder = "blobs\\in\\";	
	private String outFolder = "blobs\\out\\";
	
	public CarImage() {
		
	}

	public void setFile(String fileName){
			this.fileName = fileName;
	}
	
	public String getFile(){
		return fileName;
	}
	
	public boolean readFile() throws java.io.IOException {
		blob.readFrom(new File(inFolder + fileName));
		double status = blob.getStatus();
		while(status !=  Status.COMPLETED){
			try {
				Thread.sleep(50);
				status = blob.getStatus();
			} catch (InterruptedException ex){
				System.out.println(ex.getMessage());
			}
		}
        return (status == Status.COMPLETED);
	}
	
	public boolean writeFile() throws java.io.IOException {
		blob.writeTo(new File(outFolder + fileName));
		double status = blob.getStatus();
		while(status != Status.COMPLETED){
			try {
				Thread.sleep(50);
				status = blob.getStatus();
			} catch (InterruptedException ex){
				System.out.println(ex.getMessage());
			}
		}
        return (status == Status.COMPLETED);
	}
} .. 

inFolder ( "blobs\in\") is used as a location of existing files,  which are to be stored into db4o, ._
and outFolder ( "blobs\out\") will be the place for images, retrieved from the database.

readFile method allows blob to be read from the specified location into db4o storage:

.c blob.readFrom(new File(inFolder + fileName)); ..

As reading is done in a dedicated thread, you can create a progress window, which will be updated in the loop:

.c double status = blob.getStatus();
while(status !=  Status.COMPLETED){
try {
		Thread.sleep(50);
		status = blob.getStatus();
		// update progress window
	} catch (InterruptedException ex){
		System.out.println(ex.getMessage());
	}
} ..

The same applies to the write operation, which copies BLOB, stored with db4o, to the specified filesystem location. 
Let's store some cars together with their images in our database:

.c  public static void storeCars() {
	  new File(Util.YAPFILENAME).delete();
	  ObjectContainer db=Db4o.openFile(Util.YAPFILENAME);
	   try {
		    Car car1=new Car("Ferrari");
		    db.set(car1);
		    storeImage(car1);
		    Car car2=new Car("BMW");
		    db.set(car2);
		    storeImage(car2);
	   }  finally {
	      db.close();
	    } 
 }
  
public static void storeImage(Car car) {
	CarImage img = car.getImage();
	try {
		img.readFile();
	} catch (java.io.IOException ex){
		System.out.println(ex.getMessage());
	}
 }  ..

CarImage is stored in the database just like normal object, no BLOB data is transferred before explicit ._
call (Blob#readFrom in CarImage#readFile method), which copies the images to  the storageFolder.
Please, note, that CarImage reference should be set to the database before uploading actual data. ._

To get the images back to the filesystem we can run a usual query:

public static void retrieveCars() {
	ObjectContainer db=Db4o.openFile(Util.YAPFILENAME);
	try {
	Query query = db.query();
		query.constrain(Car.class);
		ObjectSet result = query.execute();
		getImages(result);
	}  finally {
	    db.close();
	} 
}

and get BLOB data using retrieved Car references:

private static  void getImages(ObjectSet result){
	while(result.hasNext()) {
		Car car = (Car)(result.next());
	    System.out.println(car);
	    CarImage img = car.getImage();
	    try {
	    	img.writeFile();
	    } catch (java.io.IOException ex){
	    	System.out.print(ex.getMessage());
	    }
	}
}

Retrieved images are placed in CarImage.outFolder ("blobs\out"). 
So query interface operates on references - no BLOB data is loaded into memory until explicit call (Blob#writeTo). ._
This also means, that activationDepth does not affect Blob objects and best querying performance is achieved without ._
additional coding.

.2 Full source ..

.s com.db4odoc.f1.blobs.BlobExample ..
