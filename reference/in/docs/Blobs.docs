.n
.a Blobs ..
.1 Blobs ..


In some cases user has to deal with large binary objects (BLOBs) such as images, video, music, ._
which should be stored in a structured way, and retrieved/queried easily. There are several challenges ._
associated with this task:

-	storage location;
-	loading into RAM;
-	querying interface;
-	objects' modification;
-	information backup;
-	client/server processing.

Db4o provides you with a flexibility of using 2 different solutions for this case:
1) com.db4o.types.Blob
2) byte[] arrays stored inside the database file


These two solutions' main features in comparison are represented below:

.b com.db4o.types.Blob .. 

1)	every Blob gets it's own file 
2)	C/S communication runs asynchronous in separate thread 
3)	special code is necessary to store and load 
4)	no concerns about activation depth 


.b byte[] array ..

1)	data in the same file 
2)	C/S communication runs in the normal communication thread 
3)	transparent handling without special concerns 
4)	control over activation depth may be necessary


Storing data in a byte[] array works just as storing usual objects, but this method is not always applicable/desirable. ._
First of all, the size of the db4o file can grow over the limit (256 GB) due to the BLOB data added. ._
Secondly, object activation and client/server transferring logic can be an additional load for your ._
application.

.2 db4o Blob implementation ..

Built-in db4o Blob type helps you to get rid of the problems of byte[] array, though it has its own drawbacks. Pros ._
and Cons for the points, mentioned above:

1) 
+ main database file stays a lot smaller 
+ backups are possible over individual files 
+ the BLOBs are accessible without db4o
- multiple files need to be managed 


2) 
+ asynchronous storage allows the main application thread to continue its work, while blobs are ._
being stored 

3) 
- it is more difficult to move objects between db4o database files 
4) 
+ no worries about activation depth

Let's look, how it works. 

First, BLOB storage should be defined:

.? java  .c Db4o.configure().setBlobPath(storageFolder); ..   ..?
.? net  .c Db4o.Configure().SetBlobPath(storageFolder); ..   ..?
.? mono  .c Db4o.Configure().SetBlobPath(storageFolder); ..   ..?

where storageFolder is a String value representing local or server path to store BLOBs. If that value is ._
not defined, db4o will use the default folder "blobs" in user directory.

We will use a modified Car class, which holds reference to the car photo:

.s com.db4odoc.f1.blobs.Car ..

CarImage is a wrapper to BLOB, representing the photo:

.s com.db4odoc.f1.blobs.CarImage ..

inFolder ( "blobs\in\") is used as a location of existing files,  which are to be stored into db4o, ._
and outFolder ( "blobs\out\") will be the place for images, retrieved from the database.

readFile method allows blob to be read from the specified location into db4o storage:

.? java   .c Blob#readFrom( File ); ..   ..?
.? net   .c Blob#ReadFrom( File ); ..   ..?
.? mono   .c Blob#ReadFrom( File ); ..   ..?

As reading is done in a dedicated thread, you can use Blob#getStatus() in a loop to create a progress window.

The same applies to the write operation, which copies BLOB, stored with db4o, to the specified filesystem location. 
Let's store some cars together with their images in our database:

.s com.db4odoc.f1.blobs.BlobExample#storeCars -run ..
.s com.db4odoc.f1.blobs.BlobExample#storeImage -run ..


CarImage is stored in the database just like normal object, no BLOB data is transferred before explicit ._
call (Blob#readFrom in CarImage#readFile method), which copies the images to  the storageFolder.
Please, note, that CarImage reference should be set to the database before uploading actual data. ._

To get the images back to the filesystem we can run a usual query:

.s com.db4odoc.f1.blobs.BlobExample#retrieveCars -run ..

and get BLOB data using retrieved Car references:

.s com.db4odoc.f1.blobs.BlobExample#getImages -run ..


Retrieved images are placed in CarImage.outFolder ("blobs\out"). 
So query interface operates on references - no BLOB data is loaded into memory until explicit call (Blob#writeTo). ._
This also means, that activationDepth does not affect Blob objects and best querying performance is achieved without ._
additional coding.

.2 Full source ..

.s com.db4odoc.f1.blobs.BlobExample ..
