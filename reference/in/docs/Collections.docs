.a Collections ..
.1 Collections handling ..

.l Translators Translators chapter  ..   of the documentation explains why translators are necessary to ._
store and retrieve some types of classes. Db4o uses translators internally to manage storing and ._
retrieving of collections.
.? net  Under the hood, when collection object is stored to the database it is translated with TList or TDictionary translator  ..?
.? mono  Under the hood, when collection object is stored to the database it 
is translated with TList or TDictionary translator  ..?
.? java  Collections were first implemented in JDK 1.2. Before that Vector implementation was used to store  ._
growable arrays of objects. Under the hood, when collection object is stored to the database different ._
actions are taken for different versions of java:
1)	before JDK1.2: collection class is translated with TVector class;
2)	after: collection is translated with TCollection, TMap, THashtable translators.
  ..?
In fact, the functionality of those translators is pretty much the same. On storing collection is ._
transferred to an array of objects ( Object[] ) and that array gets stored to the database file. 

Map  (HashTable and SortedList for .NET) objects are stores as an array of objects of special type:
.c
public class Entry
{
	public Object key;
	public Object value;
	. . .
}  .. 

.i OnInstantiate ..  method of collections' translators creates a new instance of respective collection or ._
map and restores its values from the saved object array.

It is easy to see that such implementation is not very efficient for searches/updates of a certain value in ._
a collection, as the whole collection should be instantiated to access any of its elements.


.2 Built-in db4o collections ..

Db4o provides its own built-in collection implementation to improve performance and decrease memory ._
consumption:
.? java  .c ObjectContainer.ext().collections.newLinkedList();
ObjectContainer.ext().collections.newHashMap();
ObjectContainer.ext().collections.newIdentityHashMap(); ..   ..?
.? net  .c ObjectContainer.Ext().Collections.NewLinkedList();
ObjectContainer.Ext().Collections.NewHashMap();
ObjectContainer.Ext().Collections.NewIdentityHashMap(); ..   ..?
.? mono  .c ObjectContainer.Ext().Collections.NewLinkedList();
ObjectContainer.Ext().Collections.NewHashMap();
ObjectContainer.Ext().Collections.NewIdentityHashMap(); ..   ..?
The LinkedList implementation only holds the first and the last elements in RAM, all the other objects are ._
loaded on demand. Apparently, this implementation provides good performance for sequential ._
traversal, but it is still quite inefficient for random selection/update. 
The HashMap implementation only holds an array of hash values in RAM and loads keys and objects on ._
demand. 
Db4o collections also provide the following functionality to help the programmer produce expected results ._
with as little work as possible:
- Newly added objects are automatically persisted.
- Collection elements are automatically activated, when they are needed. The activation depth is ._
configurable with .i Db4oCollection#activationDepth(int) ..
- Removed objects can be deleted automatically, if the list is configured with ._
.i Db4oCollection#deleteRemoved(boolean) .. 
Weak Reference system ensures that objects are freed from RAM, as soon as there are no references ._
to them.
These implementations can be faster for some cases and slower for others.

.2 Fast collections ..

Db4o's solution for the best collection performance and lowest memory consumption is to implement ._
them directly on top of BTrees without an intermediate "stored-object-db4o" layer ._
(P1Object, P1Collection, P2LinkedList). 
This task is still under development, but already it makes sense to be ready to switch to the new fast ._
collections seamlessly.
Current recommendation for collection usage with db4o is:
-	Declare members of persistent classes as interface (java.util.List / System.Collections.IList).
-	Create central factory method to implement concrete collection (can be switched to fast collection ._
implementation easily).

Please, avoid the following realizations, which will make the switching more difficult:
- Declaring concrete implementations as fields in persistent classes
- Deriving from JDK collection classes
- Using third-party non-standard collections

Let's look at application design, which will allow you to upgrade your application to fast collections with ._
the least effort.

In our example we will save a list of pilots as members of one team. To make it simple let's use the ._
following factory class to get the proper list implementation:

.s com.db4odoc.f1.lists.CollectionFactory ..

The concrete class returned by the CollectionFactory can be changed to any other collection ._
implementation (fast collection) with the minimum coding effort.

We will use the following class as a team of pilots:

.s com.db4odoc.f1.lists.Team ..

Let's try to store our team:

.s com.db4odoc.f1.lists.CollectionExample#setTeam ..

If we want to update one of the pilots, we will have to retrieve the whole collection:

.s com.db4odoc.f1.lists.CollectionExample#updateTeam ..

The idea of the new fast collection implementation is to allow select/update of collection elements without ._
an intermediate "stored-object-db4o" layer. This will allow random activation and fast querying, thus ._
providing a considerable performance improvement especially on big collections holding deep object ._
graphs.

.2 Full source ..

.s com.db4odoc.f1.lists.CollectionExample ..
.? net  .s com.db4odoc.f1.lists.VerboseList ..  ..?
.? mono  .s com.db4odoc.f1.lists.VerboseList ..  ..?