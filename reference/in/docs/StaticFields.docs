.n
.a StaticFields ..
.1 Static fields and enums ..

.2 Usage of static fields ..
As an object database db4o can take advantage of programming language specifics such as ._
static modifier. Why and where should it be used?
Usually static fields are used to store enums and constants. Obviously these objects can be ._
stored in application code only, keeping database file smaller and decreasing memory ._
consumption at runtime. But it can be not the best option in the case when the constant (enum) ._
value can be changed in application lifecycle: the references from all the database objects will ._
have to be updated explicitly.
Db4o suggests another approach to keeping constant values. For a class 
.c class Car{
	Color color;
} ..
the color field can be set to Color enumeration value like that:
.c Car car = new Car();
car.color = Color.GREEN;
objectContainer.set(car); ..
Now, when ObjectContainer is reopened and the green car is retrieved from the database, the ._
static instances in RAM will be associated with the previously persisted instances using #bind() ._
under the hood. So that the following check is possible:
.c car.color == Color.GREEN .. 
This also means that ,if Color.GREEN constant will get another internal value (RGB(0,255,10) ._
instead of RGB(0,255,0) for instance), all the references from the database will be associated with  ._
the new value.
Static field values are associated with their persistent identities only once, when an ._
ObjectContainer is opened. After that they are not stored, unless the developer does it ._
deliberately. Objects instantiation from the database does not create any more instances ._
of static values.
Since each static field exists only once in the VM, there are no versioning, locking or multiuser ._
access problems.

.2 Static fields API ..
.a StaticFieldsAPI ..
By default db4o does not persist static fields. Normally this is not necessary as static ._
values are set for a class, not for an object. However you can set up db4o to store static fields ._
if you need to implement constant or enumeration:
.c Db4o.configure().objectClass("ClassName").persistStaticFieldValues() ..
Do not use this option unnecessarily, as it will slow down the process of opening database files ._
and the stored objects will occupy space in the database file.
This option does not have any affect on primitive types (int, boolean, etc). Use their object alternatives ._
instead (Integer, Boolean, etc).
When this setting is on for a specific class, all non-primitive-typed static field values of this class ._
are stored the first time an object of the class is stored, and restored, every time a database file ._
is opened afterwards, after class meta information is loaded for this class (when the class objects ._
are retrieved with a query, for example).
A good example of non-primitive constant type is type-safe enumeration implementation:
.s com.db4odoc.f1.staticfields.PilotCategories ..
Let's use it with 
.s com.db4odoc.f1.staticfields.Pilot ..
We can try to save pilots with the default db4o settings:
.s com.db4odoc.f1.staticfields.StaticFieldExample#setPilotsSimple -out ..
.s com.db4odoc.f1.staticfields.StaticFieldExample#checkPilots ..

That does not work however. We will have to explicitly point out, which class's static fields ._
we want to save:
.s com.db4odoc.f1.staticfields.StaticFieldExample#setPilotsStatic -out ..
.s com.db4odoc.f1.staticfields.StaticFieldExample#checkPilots ..

As it was mentioned before, it is important to keep static values in one place and do not allow ._
different objects to modify them. If we try to change static value from the referencing object:
.s com.db4odoc.f1.staticfields.StaticFieldExample#updatePilots ..
the value just does not change.
In order to update static field we will have to do that explicitly:
.s com.db4odoc.f1.staticfields.StaticFieldExample#updatePilotCategories ..
.s com.db4odoc.f1.staticfields.StaticFieldExample#checkPilots ..
We can see that the reference has changed correctly. 
What about deletion? Nothing is new here. We can delete static fields from the referenced ._
object, or directly from the database:
.s com.db4odoc.f1.staticfields.StaticFieldExample#deleteTest ..

.2 Java enumerations ..
Enumerated types were brought into Java with the JDK 1.5 release. In fact they represent a ._
class with static fields similar to the one reviewed in the  .l StaticFieldsAPI previous paragraph .. .
.s com.db4odoc.f1.enum5.Qualification ..
db4o takes care about storing enumeration objects automatically without any additional settings:
.s com.db4odoc.f1.enum5.EnumExample#setPilots -out ..
.s com.db4odoc.f1.enum5.EnumExample#checkPilots ..
Another specific feature of enums in db4o: deletion is not possible:
.s com.db4odoc.f1.enum5.EnumExample#deletePilots ..
.s com.db4odoc.f1.enum5.EnumExample#checkPilots ..
Deletion of references does not automatically delete the enum. Even explicit deletion does not ._
work:
.s com.db4odoc.f1.enum5.EnumExample#deleteQualification ..
Enum update works in the same way as for normal static objects - updated enum should be ._
explicitly saved to database (#set(enum)).
.s com.db4odoc.f1.enum5.EnumExample#updateQualification ..

You can use either build-in Java enums or write your own. Db4o will take care of keeping ._
object references unique and database file as small as possible.
