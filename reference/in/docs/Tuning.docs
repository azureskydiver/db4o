.n
.a Tuning ..
.1 Tuning ..

The following is an overview over possible tuning switches ._
that can be set when working with db4o. Users that do not ._
care about performance may like to read this chapter also ._
because it provides a side glance at db4o features with ._
.i Alternate Strategies ..  and some insight on how ._
db4o works.

.2 Enable Field Indexes ..
For class Car with field "pilot":

.c Db4o.configure().objectClass(Car.class).objectField("pilot").indexed(true); ..

.i Advantage ..
The fastest way to improve the performance of your queries is to ._
enable indexing on some of your class's key fields. You can read ._
how to do it in  .l Indexes chapter of this tutorial.

Further step of index tuning is to optimize indexes for ._
Class.Field1.Field2 access. What will give us the best performance:
-	index on Field1;
-	index on Field2;
-	index on both fields?
To find the answer let's consider classes Car and Pilot from the previous ._
chapters. In order to see indexing influence we will put 10000 new cars in ._
our storage:


.s com.db4odoc.f1.indexes.IndexedExample#fillUpDB -out ..
.c   private static void AddCar(ObjectContainer db, int points)
   {
	  Car car = new Car("BMW");
      car.setPilot(new Pilot("Tester", points));
      db.set(car);
   } ..
    
Now we have lots of similar cars differing only in the amount of ._
pilots' points - that will be our constraint for the query.

.s com.db4odoc.f1.indexes.IndexedExample#noIndex ..

You can check execution time on your workstation using interactive ._
version of this tutorial.

Let's create index for pilots and their points and test the same query ._
again:

.s com.db4odoc.f1.indexes.IndexedExample#fullIndex ..

That result is considerably better and proves the power of indexing.

But do we really need 2 indexes? Will single pilot or points ._
index suffice? Let's test this as well:

.s com.db4odoc.f1.indexes.IndexedExample#pilotIndex ..

.s com.db4odoc.f1.indexes.IndexedExample#pointsIndex ..


Single index does not increase query performance on second level fields.

To maximize retrieval performance on encapsulated fields of different ._
levels of enclosure  .c Class.Field1.Field2.Field3(.FieldN) .. 
indexes for each field level should be created:
.c Class.Field1.Indexed(true)
Field1Class.Field2.Indexed(true)
Field2Class.Field3.Indexed(true)
. . .
Field(N-1)Class.FieldN.Indexed(true) ..

.i Alternate Strategies ..
Field indexes dramatically improve query performance but they may ._
considerably reduce storage and update performance. The best way ._
to decide where to put the indexes is to test them on completed application ._
with typical typical data load.

.2 Discarding Free Space ..
.c Db4o.configure().discardFreeSpace(byteCount); ..
Recommended settings for byteCount:
- Integer.MAX_VALUE will turn freespace management off
- Moderate range: 10 to 50
- Default built-in setting: 0

.i Advantage ..
will reduce the RAM memory overhead and the speed loss from ._
maintaining the freespace lists.

.i Effect ..
When objects are updated or deleted, the space previously occupied ._
in the database file is marked as "free", so it can be reused. db4o ._
maintains two lists in RAM, sorted by address and by size. Adjacent ._
entries are merged. After a large number of updates or deletes have ._
been executed, the lists can become large, causing RAM ._
consumption and performance loss for maintenance. With this ._
method you can specify an upper bound for the byte slot size to ._
discard.

.i Alternate Strategies ..
Regular defragment will also keep the number of free space slots ._
small. See:
.c com.db4o.tools.Defragment ..
(supplied as source code in ../src/com/db4o/tools)
If defragment can be frequently run, it will also reclaim ._
lost space and decrease the database file to the minimum size. ._
Therefore #discardFreeSpace() may be a good tuning mechanism ._
for setups with frequent defragment runs.


.2 Calling constructors ..
.c Db4o.configure().callConstructors(true); ..
.i Advantage ..
will configure db4o to use constructors to instantiate ._
objects.

.i Effect ..
On VMs where this is supported (Sun Java VM > 1.4, .NET, Mono) ._
db4o tries to create instances of objects without calling ._
a constructor. On Java VMs db4o is using reflection for this feature ._
so this may be considerably slower than using a constructor. For ._
the best performance on Java it is recommended to add a public ._
zero-parameter constructor to every persistent class and to turn ._
constructors on. Benchmarks on .NET have shown that the default
setting ( #callConstructors(false) ) is faster.

.i Alternate Strategies ..
Constructors can also be turned on for individual classes only with
.c Db4o.configure().objectClass(Foo.class).callConstructor(true); ..
There are some classes (e.g. java.util.Calendar) that require a constructor ._
to be called to work. Further details can be found in the ._
.l Constructors chapter on Constructors .. . 


.2 Turning Off Weak References ..
.c Db4o.configure().weakReferences(false); ..
.i Advantage ..
will configure db4o to use hard direct references instead of weak ._
references to control instantiated and stored objects.

.i Effect ..
A db4o database keeps a reference to all persistent objects that are ._
currently held in RAM, whether they were stored to the database in ._
this session or instantiated from the database in this session. ._
This is how db4o can "know" than an object is to be updated: Any ._
"known" object must be an update, any "unknown" object will be ._
stored as "new". (Note that the reference system will only be in ._
place as long as an ObjectContainer is open. Closing and reopening an ._
ObjectContainer will clean the references system of the ObjectContainer ._
and all objects in RAM will be treated as "new" afterwards.) In the ._
default configuration db4o uses weak references and a dedicated thread ._
to clean them up after objects have been garbage collected by the VM. ._
Weak references need extra ressources and the cleanup thread will ._
have a considerable impact on performance since it has to be synchronized ._
with the normal operations within the ObjectContainer. Turning off weak ._
references will improve speed. 
The downside: To prevent memory consumption from growing consistantly, ._
the application has to take care of removing unused objects from the db4o ._
reference system by itself. This can be done by calling
.c ExtObjectContainer.purge(object); ..

.i Alternate Strategies ..
.c ExtObjectContainer.purge(object); ..
can also be called in normal weak reference operation mode to remove ._
an object from the reference cache. This will help to keep the reference ._
tree as small as possible. ._
After calling #purge(object) an object will be unknown to the ._
ObjectContainer so this feature is also suitable for batch inserts. 


.2 Defragment ..
.c new Defragment().run("db.yap", delete); ..
.i Advantage ..
It is recommended to run Defragment frequently to reduce the database ._
file size and to remove unused fields and freespace slots.

.i Effect ..
db4o does not discard fields from the database file that are no longer ._
being used. Within the database file quite a lot of space is used for ._
transactional processing. Objects are always written to a new slot ._
when they are modified. Deleted objects continue to occupy 8 bytes ._
until the next Defragment run. Defragment cleans all this up by writing ._
all objects to a completely new database file. The resulting file will ._
be smaller and faster.

.i Alternate Strategies ..
Instead of deleting objects it can be an option to mark objects as ._
deleted with a "deleted" boolean field and to clean them out (by not ._
copying them to the new database file) during the Defragment run. ._
Two advantages: (1) Deleted objects can be restored. (2) ._
In case there are multiple references to a deleted object, none of them ._
would point to null. To clean out objects during the Defragment run, ._
the Defragment source code would have to be modified. ._
com.db4o.tools.Defragment is  .b only supplied as source code ..  to ._
encourage embedding maintenance tasks. ..


.2 No Shutdown Thread ..
.c Db4o.configure().automaticShutDown(false); ..
.i Advantage ..
can prevent the creation of a shutdown thread on some platforms.

.i Effect ..
On some platforms db4o uses a ShutDownHook to cleanly close all ._
database files upon system termination. If a system is terminated ._
without calling ObjectContainer#close() for all open ._
ObjectContainers, these ObjectContainers will still be usable but ._
they will not be able to write back their freespace management ._
system back to the database file. Accordingly database files will be ._
observed to grow.

.i Alternate Strategies ..
Database files can be reduced to their minimal size with
.c com.db4o.tools.Defragment ..
(supplied as source code in /src/com/db4o/tools)


.2 No callbacks ..
.c Db4o.configure().callbacks(false); ..
.i Advantage ..
will prevent db4o from looking for callback methods in all persistent ._
classes on system startup.

.i Effect ..
Upon system startup, db4o will scan all persistent classes for ._
methods with the same signature as the methods defined in ._
com.db4o.ext.ObjectCallbacks, even if the interface is not ._ 
implemented. db4o uses reflection to do so and on constrained ._
environments this can consume quite a bit of time. If callback ._
methods are not used by the application, callbacks can be turned ._
off safely.

.i Alternate Strategies ..
Class configuration features are a good alternative to callbacks. ._
The most recommended mechanism to cascade updates is:
.c Db4o.configure().objectClass("yourPackage.yourClass").cascadeOnUpdate(true);


.2 No schema changes ..
.c Db4o.configure().detectSchemaChanges(false); ..
.i Advantage ..
will prevent db4o from analysing the class structure upon opening a ._
database file.

.i Effect ..
Upon system startup, db4o will use reflection to scan the structure ._
of all persistent classes. This process can take some time, if a large ._
number of classes are present in the database file. For the best ._
possible startup performance on "warm" database files (all classes ._
already analyzed in a previous startup), this feature can be turned off.

.i Alternate Strategies ..
Instead of using one database file to store a huge and complex ._
class structure, a system may be more flexible and faster, if ._
multiple database files are used. In a client/server setup, database ._
files can also be switched from the client side with
.c ((ExtClient)objectContainer).switchToFile(databaseFile); ..


.2 No lock file thread ..
.c Db4o.configure().lockDatabaseFile(false); ..
.i Advantage ..
will prevent the creation of a lock file thread on Java platforms ._
without NIO (< JDK 1.4.1).

.i Effect ..
If file locking is not available on the system, db4o will regularily ._
write a timestamp lock information to the database file, to prevent ._
other VM sessions from accessing the database file at the same ._
time. Uncontrolled concurrent access would inevitably lead to ._
corruption of the database file. If the application ensures that it can ._
not be started multiple times against the database file, db4o file ._
locking may not be necessary.

.i Alternate Strategies ..
Database files can safely be opened from multiple sessions in readonly
mode. Use:
.c Db4o.configure().readOnly(true) ..


.2 No test instances ..
.c Db4o.configure().testConstructors(false); ..
.i Advantage ..
will prevent db4o from creating a test instance of persistent classes ._
upon opening a database file.

.i Effect ..
Upon system startup, db4o attempts to create a test instance of all ._
persistent classes, to ensure that a public zero-parameter ._
constructor is present. This process can take some time, if a large ._
number of classes are present in the database file. For the best ._
possible startup performance this feature can be turned off.

.i Alternate Strategies ..
In any case it's always good practice to create a zero-parameter ._
constructor. If this is not possible because a class from a third party ._
is used, it may be a good idea to write a translator that translates ._
the third party class to one's own class. The dowload comes with ._
the source code of the preconfigured translators in
../src/com/db4o/samples/translators.
The default configuration can be found in the above folder in the file
Default.java/Default.cs
Take a look at the way the built-in translators work to get an idea ._
how to write a translator. It just requires implementing 3 (4 for ._
ObjectConstructors) methods and configuring db4o to use a ._
translator on startup with
.c Db4o.configure().objectClass("yourPackage.yourClass").translate() ..


.2 Increasing the maximum database file size ..
.c Db4o.configure().blockSize(newBlockSize);
Defragment.main(new String[] {"mydb.yap"}); ..

.i Advantage ..
Increasing the block size from the default of 1 to a higher value permits ._
you to store more data in a db4o database.

.i Effect ..
By default db4o databases can have a maximum size of 2GB. By increasing ._
the block size that db4o should internally use, the upper limit for ._
database files sizes can be raised to multiples of 2GB. Any value ._
between 1 byte (2GB) to 127 bytes (254GB) can be chosen as the block ._
size.

Because of possible padding for objects that are not exact multiples in ._
length of the block size, database files will naturally tend to be ._
bigger if a higher value is chosen. Because of less file access cache ._
hits a higher value will also have a negative effect on performance.

A very good choice for this value is 8 bytes, because that corresponds ._
to the slot length of the pointers (address + length) that db4o ._
internally uses.

.i Alternate Strategies ..
It can also be very efficient to use multiple ObjectContainers instead of ._
one big one. Objects can be freely moved, copied and  .l Replication replicated ..  between ._
Objectcontainers.



.2 FlushFileBuffers(false) ..
.c Db4o.Configure().FlushFileBuffers(false);
.i Advantage ..
Setting FlushFileBuffers to false can considerably improve the ._
performance saving time on physical disk access.

.i Effect ..
FlushFileBuffers setting is provided to ensure correct transaction flow ._
in cases of hardware, power or operating system failures.
ACID transaction is ensured when disc writes are fulfilled in the ._
following order.

1)	a list of "pointers that are to be modified" is written to the database file;
2)	the database file is switched into "in-commit" mode;
3)	the pointers are actually modified in the database file;
4)	the database file is switched to "not-in-commit" mode.

.g trnflow.jpg ..

The Configuration.FlushFileBuffers(true) setting ensures that ._
after each stage of commit process all the buffered data ._
is written to the database file. The write process is comparatively slow ._
and can have a strong impact on performance. 

Setting FlushFileBuffers(false) reduces the time spent on transaction ._
commit. From the other side this setting can be potentially dangerous ._
on systems using in-memory file caching. The buffer cache is usually ._
used to improve writing performance. Instead of carrying out all writes ._
immediately, the kernel stores data temporally in the buffer cache, ._
waiting to see if it is possible to group several writes together. ._
Cached file changes can also be reversed. For example, if the same place ._
in a file was changed several times it is enough to write only the final ._
change. 

In case of transaction commit such cache management means that transaction ._
data may be lost. Lets consider the case when crash occurs on stage 2-4 and ._
list of "pointers to be modified" is still in cache (completely or partly). ._
After the database file is reopened the commit will be restarted using the list ._
of pointers that is supposed to be written to disc. But in fact we do not know, ._
whether the list was written to disc completely or part of it was still in ._
cache and lost during restart, - so the database can be corrupted. 


.i Alternate Strategies ..
On operating systems that cache file access, this configuration has to ._
be set to true to ensure each step of transaction being written in ._
order.

.c Db4o.Configure().FlushFileBsuffers(true);
Otherwise file caching can be switched off in OS settings.

.2 B-trees tuning ..
Db4o uses special B-tree indexes for increased query performance and reduced memory ._
consumption (the feature was introduced since version 5.4 for class indexes and since 5.7 for field indexes).

.i Advantage ..
B-trees are optimized for scenarios when part or all of a data set is on secondary storage such ._
as a hard disk, since disk accesses are extremely expensive operations. B-trees minimize the ._
number of disk accesses required to find data by traversing a sorted tree structure and only need ._
a single disk access per level of the tree. 
In order to use B-tree capabilities for field indexes you will simply need to define indexed fields in your classes:
.c Db4o.configure().objectClass(class).objectField("field").indexed(true) ..

.i Effect ..
The caching behaviour of the B-trees can be configured with the following two switches:
.c Db4o.configure().bTreeCacheHeight(height) ..
configures the size of BTree nodes in indexes.
.c Db4o.configure().bTreeNodeSize(size) ..
configures caching of B-tree nodes. Clean B-tree nodes will be unloaded on #commit and #rollback ._
unless they are configured as cached here.
Higher values for the cache height will get you better performance at more RAM consumption.
With the node size you can fine-tune exactly how many reads the B-tree will need to get to leaf ._
nodes. Lower values will allow a lower memory footprint and more efficient reading and writing ._
of small slots. Higher values will reduce the overall number of read and write operations and ._
allow better performance at the cost of more RAM use.
If you raise the number of elements per node and/or the cache depth, you will use more RAM ._
but achieve higher performance. In principle, if you set the node size to a very high value and ._
cache the first node, you should get exactly the same behavior as with the old class indexes. 
For now the default settings are 1 for the height of the cache and 100 for the size of the nodes.

When testing B-tree you should remember that B-trees only really start to give you performance ._
advantages with larger numbers of objects. With object counts of 1,000 or 10,000 the old flat index ._
is highly efficient because everything is kept in memory. Using tests with more than 100,000 objects ._
you will really see things degrade with:
- performance, because of a full purge called each time on commit
- memory consumption, because the index will be reloaded completely immediately when ._
the next object is added.

.2 Inheritance hierarchies ..
Do not create inheritance hierarchies, if you don't need them. 
.i Advantage ..
Avoiding inheritance hierarchies will help you to get better performance as only actual classes ._
will be kept in the class index and in the database.
.i Effect ..
Every class in the hierarchy requires db4o to maintain a class index. It is also true for abstract ._
classes and interfaces since db4o has to be able to run a query against them.
.i Alternate strategies ..
Class hierarchies and interfaces may be valuable for your application design. You can also ._
use interface/superclass to query for implementations/subclasses.

.2 Persistent and transient fields ..
Do not create fields that you don't need for persistence
.i Advantage ..
Storing only needed information will help to keep your database footprint as small as possible.
.i Effect ..
If your persistent class contains fields that do not need to be stored you should mark ._
them as transient to prevent them from being stored:
.? net 
.c public class NotStorable {
  [Transient] private int length;
  . . .
  } ..   ..?
.? mono  
.c
public class NotStorable {
  [Transient] private int length;
. . .
} ..   ..?
.? java  
.c
public class NotStorable {
  private transient int length;
. . . 
} ..   ..?
You can use  .l Callbacks  Callbacks ..  or .l Translators  Translators ..  to set transient fields on retrieval.
Also avoid storing classes having only transient information - their indexes' maintenance ._
will produce unnecessary performance overhead.
.i Alternate strategies ..
In some cases you may want to persist class meta-information without the actual ._
object data. The example can be database singleton for  .l Remote  remote code execution .. 

.2 Activation strategies ..
Db4o.configure().activationDepth(activationDepth)
.i Advantage ..
Db4o default activation depth is 5. This setting gives you control over activation depth ._
level depending on your application requirements.
.i Effect ..
The two extremes:
- activationDepth = Integer.MAX_VALUE - will pop the whole object graph into the memory ._
on every retrieved object. Can be a reasonable solution for shallow objects' design. No ._
need to bother about manual activation;
- activationDepth = 0 - will reduce memory consumption to the lowest level though ._
leaving all the activation logic for your code.

.i Alternate strategies ..
If your object is not fully activated due to the default configuration settings you can activate it manually:
.c ObjectContainer#activate(object,depth) ..
or use specific object settings:
.c Db4o.configure().objectClass("yourClass").minimumActivationDepth(minimumDepth) ..
.c Db4o.configure().objectClass("yourClass").maximumActivationDepth(maximumDepth) ..
.c Db4o.configure().objectClass("yourClass").cascadeOnActivate (bool) ..
.c Db4o.configure().objectClass("yourClass").ObjectField("field").cascadeOnActivate(bool) ..
For more information on activation strategies see  .l Activation Activation chapter ..  .

