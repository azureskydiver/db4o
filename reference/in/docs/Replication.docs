.n
.a Replication ..
.0 db4o Replication System ..

db4o Replication System (dRS) provides functionality to periodically synchronize databases that work disconnected from each other, such as remote autonomous servers or handheld devices synchronizing with central servers.

In order to use replication, the following configuration settings have to be called before a database file is created or opened:

.? java  .c 
public static void configureReplication(){
     Db4o.configure().generateUUIDs(Integer.MAX_VALUE); 
     Db4o.configure().generateVersionNumbers(Integer.MAX_VALUE);
} ..  ..?

.? net  .c 
public static void ConfigureReplication()
     {
       Db4o.Configure().GenerateUUIDs(Int32.MaxValue); 
       Db4o.Configure().GenerateVersionNumbers(Int32.MaxValue);
     } ..  ..?

.? mono  .c 
public static void ConfigureReplication()
     {
       Db4o.Configure().GenerateUUIDs(Int32.MaxValue); 
       Db4o.Configure().GenerateVersionNumbers(Int32.MaxValue);
     } ..  ..?

(See the section below on how to enable replication for existing databases)

Both settings can also be configured on a per-class basis:

.? java  .c 
public static void configureReplicationPilot(){
     Db4o.configure().objectClass(Pilot.class).generateUUIDs(true); 
     Db4o.configure().objectClass(Pilot.class).generateVersionNumbers(true);
} ..  ..?

.? net  .c 
public static void ConfigureReplicationPilot()
     {
       Db4o.Configure().ObjectClass(typeof(Pilot)).GenerateUUIDs(true); 
       Db4o.Configure().ObjectClass(typeof(Pilot)).GenerateVersionNumbers(true);
     } ..  ..?

.? mono  .c 
public static void ConfigureReplicationPilot()
     {
       Db4o.Configure().ObjectClass(typeof(Pilot)).GenerateUUIDs(true); 
       Db4o.Configure().ObjectClass(typeof(Pilot)).GenerateVersionNumbers(true);
     } ..  ..?
     
Suppose we have opened two ObjectContainers from two different databases called "handheld" and "desktop", that we want to replicate. This is how we do it:     
.? java  .c
public static void replicate(){
     ObjectContainer desktop=Db4o.openFile(DTFILENAME);
     ObjectContainer handheld=Db4o.openFile(HHFILENAME);
         //     Setup a replication session
     ReplicationSession replication = Replication.begin(handheld, desktop);
     
     /*
      * There is no need to replicate all the objects each time. 
      * objectsChangedSinceLastReplication methods gives us 
      * a list of modified objects
      */
     ObjectSet changed =  replication.providerA().objectsChangedSinceLastReplication();
     
     // Iterate changed objects, check if the name starts with "S" and replicate only those items
     while (changed.hasNext()) {
       replication.replicate(changed.next());
     }
     
     replication.commit();
   } ..   ..?
   
.? net  .c
public static void Replicate()
     {
       ObjectContainer desktop=Db4o.OpenFile(DtFileName);
       ObjectContainer handheld=Db4o.OpenFile(HhFileName);
       com.db4o.drs.ReplicationSession replication = com.db4o.drs.Replication.Begin(handheld, desktop);
       /*
        * There is no need to replicate all the objects each time. 
        * ObjectsChangedSinceLastReplication methods gives us 
        * a list of modified objects
        */
       com.db4o.ObjectSet changed = replication.ProviderA().ObjectsChangedSinceLastReplication();
       //Iterate changed objects, replicate them
       while (changed.HasNext())
       {
         com.db4o.drs.quickstart.simple.Pilot p = (com.db4o.drs.quickstart.simple.Pilot)changed
           .Next();
         if (p._name.StartsWith("S"))
         {
           replication.Replicate(p);
         }
       }
       replication.Commit();
     } ..   ..?

.? mono  .c
public static void Replicate()
     {
       ObjectContainer desktop=Db4o.OpenFile(DtFileName);
       ObjectContainer handheld=Db4o.OpenFile(HhFileName);
       com.db4o.drs.ReplicationSession replication = com.db4o.drs.Replication.Begin(handheld, desktop);
       /*
        * There is no need to replicate all the objects each time. 
        * ObjectsChangedSinceLastReplication methods gives us 
        * a list of modified objects
        */
       com.db4o.ObjectSet changed = replication.ProviderA().ObjectsChangedSinceLastReplication();
       //Iterate changed objects, replicate them
       while (changed.HasNext())
       {
         com.db4o.drs.quickstart.simple.Pilot p = (com.db4o.drs.quickstart.simple.Pilot)changed
           .Next();
         if (p._name.StartsWith("S"))
         {
           replication.Replicate(p);
         }
       }
       replication.Commit();
     } ..   ..?

That's all there is to it.

We are using a query that will return all objects but we could use any query we like to constrain the objects we want.

Calling whereModified() will add a constraint to the query so that it only returns the objects that have actually been modified since the last replication between both the containers in question.

After replication commit, all modified objects (INCLUDING THE ONES THAT WERE NOT REPLICATED) are considered to be "in sync" and will not show up in future "where modified" queries, unless they are modified again.

.1 Under the Hood ..

Let's take a look at the necessary configuration calls to tell db4o to generate version numbers and UUIDs:

(1) An object's version number indicates the last time an object was modified. It is the database version at the moment of the modification. The database version starts at zero and is incremented every time a transaction is commited.

(2) UUIDs are object IDs that are unique across all databases created with db4o. That is achieved by having the database's creation timestamp as part of its objects' UUIDs. Manually copying db4o database files can produce duplicate UUIDs, of course.

When the replication process is commited, the lowest database version number among both databases is set to be equal to the highest. After replication commit, therefore, both databases have the same version number and are "in sync".

.1 Replicating Existing Data Files ..

As we learned in the last sections, Db4o.configure().generateUUIDs() and Db4o.configure().generateVersionNumbers()  (or its objectClass counterparts) must be called before storing any objects to a data file because db4o replication needs object versions and UUIDs to work. This implies that objects in existing data files stored without the correct settings can't be replicated.

Fortunately enabling replication for existing data files is a very simple process:
We just need to use the Defragment tool in com.db4o.tools (source code only) after enabling replication:   
.? java  .c
public static void configureForExisting(){
     Db4o.configure().objectClass(Pilot.class).enableReplication(true); 
     new Defragment().run(DTFILENAME, true);
   } ..   ..?
   
.? net  .c
public static void ConfigureForExisting()
     {
       Db4o.Configure().ObjectClass(typeof(Pilot)).EnableReplication(true); 
       new Defragment().Run(DtFileName, true);
     } ..   ..?   
     
.? mono  .c
public static void ConfigureForExisting()
     {
       Db4o.Configure().ObjectClass(typeof(Pilot)).EnableReplication(true); 
       new Defragment().Run(DtFileName, true);
     } ..   ..?        
     
After a successful defragmentation our data files are ready for replication.