.n
.a Diagnostics ..
.1 Diagnostics ..

Db4o engine provides user with a special mechanism showing runtime ._
diagnostics information. This functionality can become your guide ._
to excellent performance and low memory consumption.
Diagnostics can be switched on in the configuration before opening ._
the database file:
.c Db4o.Configure().Diagnostic().AddListener(new DiagnosticListener ()) ..
where DiagnosticListener is a callback interface tracking ._
diagnostic messages from different parts of the system:
.c public interface DiagnosticListener {
    public void onDiagnostic(Diagnostic d);
} ..
Db4o provides 2 different listeners:

- DiagnosticToConsole (Java, prints diagnostic messages to the console);
- DiagnosticToTrace (.NET, prints diagnostic messages to the debug output window).

Every diagnostic message is represented by it's own type, all ._
possible types can be found in the com.db4o.diagnostic ._
package/namespace.
At the present moment the following diagnostic classes are._
implemented:
- ClassHasNoFields 
- LoadedFromClassIndex 
- NativeQueryNotOptimized 
- UpdateDepthGreaterOne
- DescendIntoTranslator

.2 ClassHasNoFields ..
This diagnostic type provides information about classes in your ._
persistent class hierarchy that have no persistent fields. The ._
diagnostic message appears when the class is saved to the ._
database. It is recommended to remove such classes ._
from the database to avoid the overhead for the ._
maintenance of class indexes.
Let's look at the following example:
.c package  com.db4odoc.f1.diagnostics;

import java.util.Calendar;
import java.text.DateFormat;


public class Empty {    
    
    public Empty() {
    }
        
	public String CurrentTime()
	{
		Calendar cl = Calendar.getInstance();
		DateFormat df = DateFormat.getDateTimeInstance();
		String time = df.format(cl.getTime());
		return time;
	}

	public String ToString()
	{
		return CurrentTime();
	}
} ..
.c private static void setEmptyObject(ObjectContainer db){
  	Empty empty = new Empty();
    db.set(empty);
} ..
.s com.db4odoc.f1.diagnostics.DiagnosticExample#testEmpty ..

Diagnostic message is produced when the execution point reaches 
.c	db.set(empty); ..
Empty class does not keep any ._
information and can be left in the application code; there is no ._
need to put it in the database.

.2 LoadedFromClassIndex ..
This diagnostic class is provided to keep track of all the queried ._
fields in your application that have no indexes. The output ._
produced can give a comprehensive picture of index tuning required.

.2 NativeQueryNotOptimized ..
This diagnostics object informs you that a Native Query cannot be ._
optimized. It means that it will be run by instantiating all ._
objects of the candidate class. Try to simplify your query ._
expression.
For an example let's look at a predicate using 2 different ._
unrelated clauses.
.c package com.db4odoc.f1.diagnostics;
import com.db4o.query.Predicate;

public class ArbitraryQuery extends Predicate{    
    private int[] points;
    
    public ArbitraryQuery(int[] points) {
        this.points=points;
    }
    
    public boolean match(Pilot pilot) {
    	for (int i = 0; i < points.length; i++) {
 			if (pilot.getPoints() == points[i])
			{
				return true;
			}
		}
		return pilot.getName().startsWith("Rubens");
    }
    
} ..
.c private static void queryPilot(ObjectContainer db){
    	int[]  i = new int[]{99,0};
    	ObjectSet result = db.query(new ArbitraryQuery(i));
    	listResult(result);
} ..
.s com.db4odoc.f1.diagnostics.DiagnosticExample#testArbitrary ..


.2 UpdateDepthGreaterOne ..
UpdateDepth configuration setting allows you to specify the level ._
of objects' enclosure where update command will still be valid:
.c Db4o.Configure().UpdateDepth(depth); ..
This setting has a considerable impact on performance and can make ._
the application very slow. It is recommended to keep the default ._
configuration setting (UpdateDepth(1)) and specify UpdateDepth for ._
selected classes, where cascaded update will be really useful: 
.c Db4o.Configure().ObjectClass(typeof(Car)).UpdateDepth(3); ..

.a DiagnosticMessagesFilter ..
.2 Diagnostic Messages Filter ..

The standard listeners can potentially produce quite a lot of ._
messages. By writing your own DiagnosticListener you can filter ._
that information.

On the stage of application tuning you can be interested in ._
optimizing performance through indexing. Diagnostics can help you with ._
that giving information about queries that are running on ._
un-indexed fields. Having this information you can decide which ._
queries are frequent and heavy and should be indexed, and which ._
have little performance impact and do not need an index. Field ._
indexes dramatically improve query performance but they may ._
considerably reduce storage and update performance. 

In order to get rid of all unnecessary diagnostic information and ._
concentrate on indexes let's create special diagnostic listener:
.c package com.db4odoc.f1.diagnostics;

import com.db4o.diagnostic.*;

public class IndexDiagListener  extends DiagnosticToConsole
{
	   public void onDiagnostic(Diagnostic d) {
		   if (d.getClass().equals(LoadedFromClassIndex.class)){
	        System.out.println(d.toString());
		   }
	    }
} ..
The following command will install the new listener:
.c Db4o.Configure().Diagnostic().AddListener(new IndexDiagListener()); ..
We can check the efficacy of IndexDiagListener using queries from ._
the previous paragraphs:
.s com.db4odoc.f1.diagnostics.DiagnosticExample#testIndexDiagnostics ..
Potentially this piece of code triggers all the diagnostic objects, ._
but we are getting only index warning messages due to ._
IndexDiagListener.

.2 DescendIntoTranslator
Translator API provides a special way of storing and retrieving ._
objects. In fact the actual class is not stored in the database. ._
Instead the information from that class is stored in a primitive ._
object (object array) and the class is recreated during instantiation ._
or activation.
Let's look how queries handle translated classes. Diagnostics system ._
will help us to see, what is going on.
In our example class Car is configured to be saved and retrieved with ._
CarTranslator class. CarTranslator saves only car model information ._
appending it with the production date. 

.c package com.db4odoc.f1.evaluations;

import com.db4o.*;
import com.db4o.config.*;

public class CarTranslator 
    implements ObjectConstructor {
  public Object onStore(ObjectContainer container,
      Object applicationObject) {
    Car car =(Car)applicationObject;

    String fullModel = car.getModel() + getYear(car.getModel()); 
    return new Object[]{fullModel};
  }

  private String getYear(String carModel){
	  if (carModel.equals("BMW")){
		  return " 2002";
	  } else {
		  return " 1999";
	  }
	  
  }
  
  public Object onInstantiate(ObjectContainer container, Object storedObject) {
    Object[] raw=(Object[])storedObject;
    String model=(String)raw[0];
    return new Car(model);
  }

  public void onActivate(ObjectContainer container, 
      Object applicationObject, Object storedObject) {
  }

  public Class storedClass() {
    return Object[].class;
  }
} ..

Let's clean our database and store 2 cars:
.s com.db4odoc.f1.diagnostics.DiagnosticExample#storeTranslatedCars ..

We can check the contents of our database with the following method:
.s com.db4odoc.f1.diagnostics.DiagnosticExample#retrieveTranslatedCars ..

TranslatorDiagListener is implemented to help us filter only those ._
diagnostic messages, that concern translated classes (filtering ._
diagnostics messages is explained in ._
.l DiagnosticMessagesFilter Diagnostic Messages Filter ..  chapter).
We did not get any diagnostic messages here and the result shows ._
the stored cars with extended model values.
To test Native Queries we will use the predicate, which retrieves ._
only cars, produced in year 2002:

.c package com.db4odoc.f1.diagnostics;

import com.db4odoc.f1.evaluations.*;
import com.db4o.query.Predicate;

public class NewCarModel  extends Predicate {
	public boolean match(Car car) {
		return car.getModel().endsWith("2002");
	}
} ..
.s com.db4odoc.f1.diagnostics.DiagnosticExample#retrieveTranslatedCarsNQ ..

We did not get any results and the diagnostic message points out, ._
that the query is not correct in our case. Let's follow the ._
diagnostic advice and try unoptimized NQ and evaluations.
.s com.db4odoc.f1.diagnostics.DiagnosticExample#retrieveTranslatedCarsNQUnopt ..

We will use simple evaluation to check our cars:
.c package com.db4odoc.f1.diagnostics;

import com.db4o.query.*;
import com.db4odoc.f1.evaluations.*;

public class CarEvaluation implements Evaluation {
	public void evaluate(Candidate candidate)
	{
		Car car=(Car)candidate.getObject();
		candidate.include(car.getModel().endsWith("2002"));
	}
} ..
.s com.db4odoc.f1.diagnostics.DiagnosticExample#retrieveTranslatedCarsSODAEv ..

In both cases we are getting correct results.
Native Query optimization cannot be used with the translated ._
classes, because the actual values of the translated fields are ._
only known after instantiation and activation. That also means ._
that translated classes can have a considerable impact on database ._
performance and should be used with care.

