.n
.a Structured ..
.1 Working With Structured Objects ..

In real world objects are referenced by each other creating deep reference structures.
This chapter will give you an overview of how db4o deals with structured objects.
For an example we will use a simple model, where Pilot class is referenced from Car class.
.s com.db4odoc.f1.structured.Pilot ..
.s com.db4odoc.f1.structured.Car ..

.2 Storing structured objects ..

To store a car with its pilot, you just call set() on the top level object, ._
the car. The pilot will be stored implicitly.

.s com.db4odoc.f1.structured.StructuredExample#storeFirstCar -out ..

Another way to do the same thing: store the pilot explicitly ._
before entering the car.

.s com.db4odoc.f1.structured.StructuredExample#storeSecondCar -out ..

.2 Retrieving structured objects ..

.3 QBE ..

To retrieve all cars a simple 'blank' prototype can be used.

.s com.db4odoc.f1.structured.StructuredExample#retrieveAllCarsQBE ..

You can also query for all pilots, of course.

.s com.db4odoc.f1.structured.StructuredExample#retrieveAllPilotsQBE ..

Now let's initialize the prototype to specify all cars driven by ._
Rubens Barrichello.

.s com.db4odoc.f1.structured.StructuredExample#retrieveCarByPilotQBE ..

What about retrieving a pilot by car? You simply don't need that - ._
if you already know the car, you can simply access the pilot field ._
directly.

.3 Native Queries ..

Using native queries with constraints on deep structured objects ._
is straightforward, you can do it just like you would in plain ._
other code. 

Let's constrain our query to only those cars driven by a Pilot ._
with a specific name:

.? net  .s com.db4odoc.f1.structured.StructuredExample#retrieveCarsByPilotNamePredicate +{} -run ..s  ..?
.s com.db4odoc.f1.structured.StructuredExample#retrieveCarsByPilotNameNative ..


.3 SODA Query API ..

In order to use SODA for querying for a car given its pilot's name you have ._
to descend two levels into our query.

.s com.db4odoc.f1.structured.StructuredExample#retrieveCarByPilotNameQuery ..

You can also constrain the pilot field with a prototype to achieve ._
the same result.

.s com.db4odoc.f1.structured.StructuredExample#retrieveCarByPilotProtoQuery ..

Descending into a query provides you with another ._
query. Starting out from a query root you can descend in multiple directions. ._
In practice this is the same as ascending from one child to a parent ._
and descending to another child. The queries turn ._
one-directional references in objects into true relations. ._
Here is an example that queries for "a Pilot that is being referenced ._
by a Car, where the Car model is 'Ferrari'":

.s com.db4odoc.f1.structured.StructuredExample#retrievePilotByCarModelQuery ..

.g querygraph/3.gif ..

.2 Updating structured objects ..

To update structured objects in db4o, you simply call set() on them again.

.s com.db4odoc.f1.structured.StructuredExample#updateCar ..

Let's modify the pilot, too.

.s com.db4odoc.f1.structured.StructuredExample#updatePilotSingleSession ..

Nice and easy, isn't it? But there is something that is not obvious in this example. ._
Let's see what happens if we split this ._
task in two separate db4o sessions: In the first we modify our ._
pilot and update his car:

.s com.db4odoc.f1.structured.StructuredExample#updatePilotSeparateSessionsPart1 -out ..

And in the second, we'll double-check our modification:

.s com.db4odoc.f1.structured.StructuredExample#updatePilotSeparateSessionsPart2 ..

If you will execute this code you will see that Pilot's points are not changed ._
What's happening here and what can we do to fix it?

.3 Update depth ..

Imagine a complex object with many members that have many members themselves. ._
When updating this object, db4o would have to update all its children, ._
grandchildren, etc. This poses a severe performance penalty and will ._
not be necessary in most cases - sometimes, however, it will.

So, in our previous update example, we were modifying the Pilot child of a Car ._
object. When we saved the change, we told db4o to save our Car object and assumed ._
that the modified Pilot would be updated. But we were modifying and saving in the ._
same manner as we were in the first update sample, so why did it work before? The ._
first time we made the modification, db4o never actually had to retreive the modified ._
Pilot ... it returned the same one that was still in memory that we modified, but ._
it never actually updated the database. Restarting the application would show that the value was unchanged.

To be able to handle this dilemma as flexible as possible, db4o introduces ._
the concept of update depth to control how deep an object's member tree will ._
be traversed on update. The default update depth for all objects is 0, meaning ._
that only primitive and String members will be updated, but changes in object ._
members will not be reflected.

db4o provides means to control update depth with very fine granularity. ._
For our current problem we'll advise db4o to update the full graph for ._
Car objects by setting cascadeOnUpdate() for this class accordingly.

.s com.db4odoc.f1.structured.StructuredExample#updatePilotSeparateSessionsImprovedPart1 -out ..

.s com.db4odoc.f1.structured.StructuredExample#updatePilotSeparateSessionsImprovedPart2 -out ..

.s com.db4odoc.f1.structured.StructuredExample#updatePilotSeparateSessionsImprovedPart3 ..

You can also achieve expected results using:
1.ExtObjectContainer#set(object, depth) to update exact amount of referenced fields
2. Use Db4o.configure().objectClass(clazz).updateDepth(depth) setting ._
to define sufficient update depth for a specific object
3. Use global setting for all the persisted objects:
.c Db4o.configure().updateDepth(depth); ..
However global updateDepth is not flexible enough for real-world objects having different ._
depth of reference structures. 

Note that container configuration must be set before the container is opened.

.2 Deleting structured objects ..

As we have already seen, we call delete() on objects to get rid of them.

.s com.db4odoc.f1.structured.StructuredExample#deleteFlat ..

Fine, the car is gone. What about the pilots?

.s com.db4odoc.f1.structured.StructuredExample#retrieveAllPilotsQBE ..                                    

Ok, this is no real surprise - we don't expect a pilot to vanish when his ._
car is disposed of in real life, too. But what if we want an object's children ._
to be thrown away on deletion, too?

.3 Recursive deletion ..

You may already suspect that the problem of recursive deletion (and ._
perhaps its solution, too) is quite similar to our little update problem, and you're ._
right. Let's configure db4o to delete a car's pilot, too, when the car is deleted.

.s com.db4odoc.f1.structured.StructuredExample#deleteDeepPart1 -out ..
.s com.db4odoc.f1.structured.StructuredExample#deleteDeepPart2 ..

Again: Note that all configuration must take place before the ObjectContainer is opened.

Let's have a look at our pilots again.

.s com.db4odoc.f1.structured.StructuredExample#retrieveAllPilots ..

.3 Recursive deletion revisited ..

But wait - what happens if the children of a removed object are still referenced by ._
other objects?

.s com.db4odoc.f1.structured.StructuredExample#deleteDeepRevisited ..

.s com.db4odoc.f1.structured.StructuredExample#retrieveAllPilots ..

Currently db4o does  .b not ..  check whether objects to be deleted are referenced anywhere ._
else, so please be very careful when using this feature.
However it is fairly easy to implement referential checking on deletion 
using ObjectCanDelete callback. See  .l Callbacks Callbacks chapter ..  
for more information.

.2 Full source ..

.s com.db4odoc.f1.structured.StructuredExample ..
