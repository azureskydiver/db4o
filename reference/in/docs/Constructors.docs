.n
.a Constructors ..
.1 Objects Instantiation  ..

Sometimes you may find that db4o refuses to store instances of certain ._
classes, or appears to store them, but delivers incomplete instances ._
on queries. To understand the problem and the alternative solutions ._
at hand, we'll have to take a look at the way db4o "instantiates" ._
objects when retrieving them from the database.

.2 Creating objects ..

Db4o currently knows three ways of creating and populating an object ._
from the database. The approach to be used can be configured globally ._
and on a per-class basis.

.3 Using a constructor ..

The most obvious way is to call an appropriate constructor. Db4o does ._
.i not ..  require a public or no-args constructor. It can use any ._
constructor that accepts default (null/0) values for all of its ._
arguments without throwing an exception. Db4o will test all available ._
constructors on the class (including private ones) until it finds ._
a suitable one.

What if no such constructor exists?

.3 Bypassing the constructor ..

Db4o can also bypass the constructors declared for this class using ._
platform-specific mechanisms. (For Java, this option is only available ._
on JREs >= 1.4.) This mode allows reinstantiating objects whose class ._
doesn't provide a suitable constructor, However, it will (silently) break ._
classes that rely on the constructor to be executed, for example in order to ._
populate transient members.

.i If this option is available in the current runtime environment, it will be the default setting. ..i

.3 Using a translator ..

If none of the two approaches above is suitable, db4o provides a way ._
to specify in detail how instances of a class should be stored and ._
reinstantiated by implementing the Translator interface and registering ._
this implementation for the offending class.

Translators in detail in the  .l Translators Translators chapter ..l .

.2 Configuration ..

The instantiation mode can be configured globally or on a per class ._
basis.
.? java  
.c
Db4o.configure().callConstructors(true);
..c  ..?

.? net  
.c
Db4o.Configure().CallConstructors(true);
..c  ..?

.? mono  
.c
Db4o.Configure().CallConstructors(true);
..c  ..?

This will configure db4o to use constructors to reinstantiate any object ._
from the database. (The default is .i false ..i).
.? java  
.c
Db4o.configure().objectClass(Foo.class).callConstructor(true);
..c   ..?

.? net  
.c
Db4o.Configure().ObjectClass(typeof(Foo)).CallConstructor(true);
..c   ..?

.? mono  
.c
Db4o.Configure().ObjectClass(typeof(Foo)).CallConstructor(true);
..c   ..?
This will configure db4o to use constructor calls for this class and ._
all its subclasses.

.2 Troubleshooting ..

At least for development code, it is always a good idea to instruct ._
db4o to check for available constructors at storage time. (If you've ._
configured db4o to use constructors at all.)

.c
Db4o.configure().exceptionsOnNotStorable(true);
..c

If this setting triggers exceptions in your code, or if instances of a class ._
seem to lose members during storage, check the involved classes ._
(especially their constructors) for problems similar to the ones ._
shown in the following section.

.2 Examples ..
.s com.db4odoc.f1.constructors.C1 ..
	
The above class is fine for use with and without callConstructors set.
.s com.db4odoc.f1.constructors.C2 ..
The above C2 class needs to have callConstructors set to true. Otherwise, since ._
transient members are not stored and the constructor code is not ._
executed, toString() will potentially run into a NullPointerException on x.length().
.s com.db4odoc.f1.constructors.C3 ..
The above C3 class needs to have callConstructors set to false (the default), ._
since the (only) constructor will throw a NullPointerException when ._
called with a null value.
.s com.db4odoc.f1.constructors.C4 ..
This class cannot be cleanly reinstantiated by db4o: Both approaches ._
will fail, so one has to resort to configuring a translator.