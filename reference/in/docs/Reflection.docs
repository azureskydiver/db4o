.n
.1 db4o Reflection API ..
.a Reflection .. 

Reflection API gives your code access to internal information for classes loaded into the ._
VM(Java) / common runtime (.NET). It allows you to work with classes defined in runtime ._
and not in code.
Reflection works with metadata - data that describes other data. In the case of reflection ._
metadata is the description of classes and objects within the JVM or .NET assembly, ._
including their fields, methods and constructors. It allows the programmer to select target ._
classes in runtime, create new objects, call their methods and operate with the fields.
These features make reflection especially useful for creating libraries that work with objects ._
in very general ways. For example, reflection is often used in frameworks that persist objects ._
to databases, XML, or other external formats.
For more information about reflection see Java or .NET Reflection API.

.2 GenericReflector ..

Db4o uses reflection internally for persisting and instantiating user objects. Reflection helps db4o to ._
manage classes in a general way while saving. It also makes possible instantiation of user objects ._
using class name saved in the database file and class information from the JVM or .NET assembly. However db4o reflection ._
API can also work on generic objects when the class information is not available.
Db4o uses GenericReflector as a wrapper around specific reflector (delegate). GenericReflector is ._
set when an ObjectContainer is opened. All subsequent reflector calls are routed through this ._
interface. 
GenericReflector keeps list of known classes in memory. When the GenericReflector is called, it first ._
checks its list of known classes. If the class cannot be found, the task is transferred to the delegate ._
reflector. If the delegate fails as well, generic objects are created, which hold simulated "field values" ._
in an array of objects.
Generic reflector makes possible the following usecases:
  - running a db4o server without deploying application classes;
  - running db4o on Java dialects without reflection (J2ME CLDC, MIDP);
  - easier access to stored objects where classes or fields are not available;
  - running refactorings in the reflector;
  - building interfaces to db4o from any programming language.

One of the live usecases is ObjectManager, which uses GenericReflector to read C# objects from Java.

.2 Using db4o reflection API ..

Db4o reflector can be used in your application just like normal java reflector. Let's create a new ._
database with a couple of cars in it:

.s com.db4odoc.f1.reflections.ReflectorExample#setCars ..

We can check, what information is available for db4o reflector:

.s com.db4odoc.f1.reflections.ReflectorExample#getReflectorInfo ..

All the information about Car class can also be retrieved through reflector:

.s com.db4odoc.f1.reflections.ReflectorExample#getCarInfo ..

We can use classes retrieved using reflection to create queries:

.s com.db4odoc.f1.reflections.ReflectorExample#getCars ..


.2 Creating your own reflector ..

By default db4o uses JdkReflector(Java) or NetReflector (.NET) as a GenericReflector delegate.

However, the programmer can instruct db4o to use a specially designed reflection implementation:

.c Db4o.configure().reflectWith(reflector) ..

where reflector is one of the available reflectors or your own reflector implementation. 
At present db4o comes with SelfReflector, which was designed for environments, which do not ._
have built-in support for reflections (J2ME for example). In this implementation all the classes’ ._
information is stored in special registry. User classes should implement self_get and self_set ._
methods to be registered individually and become “known” to SelfReflector. 

Specific reflectors can be written for special usecases. 
Let's look how to create a reflector. Remember that db4o relies on reflector to read the database, ._
so errors in reflector may prevent your database from opening.
To keep things simple we will write a LoggingReflector, its only difference from standard reflector ._
is that information about loaded classes is outputted to console. All reflectors used by db4o should ._
implement com.db4o.reflect.Reflector interface.

.s com.db4odoc.f1.reflections.LoggingReflector ..

It is easy to see that this reflector provides the same functionality as JdkReflector extended by console ._
output. The following simple test will show how it works:

.s com.db4odoc.f1.reflections.ReflectorExample#testReflector ..

The output can help you to track all the loaded classes. 

Reflection is a powerful tool, which plays a fundamental role in db4o. Understanding reflection will ._
help you to understand the whole db4o functionality in detail. 







