.n
.a Transactions ..
.0 Transaction ..

.1 Commit and rollback ..

All work within db4o ObjectContainer is transactional. A transaction ._
is implicitly started when you open a container, and the current transaction ._
is implicitly committed when you close it again. 
You may choose to make ._
a commit explicit or you may leave it for the #close call:

.s com.db4odoc.f1.clientserver.TransactionExample#storeCarCommit -out ..

.s com.db4odoc.f1.clientserver.TransactionExample#listAllCars ..

Before transaction is commited all the modifications to a database are written ._
to a temporary memory storage. Commit (explicit or implicit) writes the modifications ._
to the disk. 

Please, remember to always commit or close your ObjectContainer when the work ._
is done, to make sure that the data is saved to the permanent storage.

If you do not want to save changes to the database, you can call rollback, ._
resetting the ._
state of our database to the last commit point.

.s com.db4odoc.f1.clientserver.TransactionExample#storeCarRollback -out ..

.s com.db4odoc.f1.clientserver.TransactionExample#listAllCars ..


.1 Refresh live objects ..

There is one thing that you should remember when rolling back:
rollback method will cancel the modifications, but it won't change back the state ._
of the objects in your reference cache.

.s com.db4odoc.f1.clientserver.TransactionExample#carSnapshotRollback ..

You have to explicitly refresh your live objects when their state might become ._
different from the state in the database:

.s com.db4odoc.f1.clientserver.TransactionExample#carSnapshotRollbackRefresh ..

#refresh method might be also helpful when the changes to the database are done ._
from different threads.  See  .l ClientServer Client/Server chapter  ..   for more information.

.1 Full source ..

.s com.db4odoc.f1.clientserver.TransactionExample ..
