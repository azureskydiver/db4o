<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="8" MadCap:lastHeight="2266" MadCap:lastWidth="623">
  <head />
  <body>
    <h1>
      <MadCap:keyword term="In Memory Database;Storage:Memory" />Memory Storage</h1>
    <p>The MemoryStorage allows you to create
and use a db4o database fully in RAM. This strategy eliminates long disk access
times and makes db4o much faster.</p>
    <MadCap:snippetBlock src="../../../CodeExamples/configuration/io/IOConfigurationExamples-Using-memory-storage.all.flsnp" />
    <p>MemoryStorage can be
created without any additional parameters passed to the constructor. In this
case default configuration values will be used. </p>
    <h2>PagingMemoryStorage</h2>
    <p>The regular MemoryStorage implementation keeps all the content in a single byte-array. However this brings some issues. When the database outgrows the array-size, a new, larger array is created and the content is copied over. This can be quite slow. Also can cause this a out of memory exception, because during the copying these two large arrays are present. Also, on some runtimes large objects are treated different by the garbage-collector and are less often collected. </p>
    <p>To avoid all this issues, the PagingMemoryStorage uses multiple, small arrays to keep the database in memory. When the database outgrows the storage, only such a smaller arrays needs to be allocated. The old content stays in the existing arrays. No coping is required. </p>
    <p>However managing these arrays cost some small overhead. But for lots of cases, the PagingMemoryStorage is the better choice.</p>
    <MadCap:snippetBlock src="../../../CodeExamples/configuration/io/IOConfigurationExamples-Using-paging-memory-storage.all.flsnp" />
    <h2>Growth Strategy for MemoryStorage</h2>
    <p>Growth strategy defines
how the database storage (reserved disk or memory space) will grow when the
current space is not enough anymore.</p>
    <p>DoublingGrowthStrategy - default
setting. When the size of the database is not enough, the reserved size will be
doubled.</p>
    <p>ConstantGrowthStrategy -
a configured amount of bytes will be added to the existing size when necessary.</p>
    <MadCap:snippetBlock src="../../../CodeExamples/configuration/io/IOConfigurationExamples-Using-memory-storage-with-constant-grow-strategy.all.flsnp" />
    <h2>MemoryBin</h2>
    <p>Each memory storage can contain a collection of memory bins, which are
actually just names memory storages. You can reuse the MemoryBin created
earlier for this MemoryStorage. MemoryBins are identified
by their URI, i.e. when an object container is opened with:</p>
    <p MadCap:conditions="Primary.Java,Primary.All languages">
      <p>Java:  </p>
      <p>
        <code>Db4oEmbedded.openFile(embeddedConfiguration,
"myEmbeddedDb.db4o");</code>
      </p>
    </p>
    <p MadCap:conditions="Global.Primary:java" />
    <p MadCap:conditions="Primary..NET">
      <p>.NET:  </p>
      <p>
        <code>Db4oEmbedded.OpenFile(embeddedConfiguration,
"myEmbeddedDb.db4o");</code>
      </p>
    </p>
    <p MadCap:conditions="Global.Primary:net" />
    <p>A MemoryBin with URI = "myEmbeddedDb.db4o"
will be used. If this memory bin does not exist in the storage when the
container is opened, a new MemoryBin will be created and associated with this
URI. When you pass the same memory storage to multiple object containers these containers can access to the same in memory file when they are using the same name.</p>
    <p>More Reading:<ul><li><p><a href="memory_storage/storing_memorybin_data.htm">Storing MemoryBin Data</a></p></li></ul></p>
  </body>
</html>