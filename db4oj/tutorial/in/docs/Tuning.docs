.n
.a Tuning ..
.0 Tuning ..

The following is an overview over possible tuning switches ._
that can be set when working with db4o. Users that do not ._
care about performance may like to read this chapter also ._
because it provides a side glance at db4o features with ._
.i Alternate Strategies ..  and some insight on how ._
db4o works.


.1 Discarding Free Space ..
.c Db4o.configure().discardFreeSpace(byteCount); ..
Recommended settings for byteCount:
- Integer.MAX_VALUE will turn freespace management off
- Moderate range: 10 to 50
- Default built-in setting: 0

.i Advantage ..
will reduce the RAM memory overhead and the speed loss from ._
maintaining the freespace lists.

.i Effect ..
When objects are updated or deleted, the space previously occupied ._
in the database file is marked as "free", so it can be reused. db4o ._
maintains two lists in RAM, sorted by address and by size. Adjacent ._
entries are merged. After a large number of updates or deletes have ._
been executed, the lists can become large, causing RAM ._
consumption and performance loss for maintenance. With this ._
method you can specify an upper bound for the byte slot size to ._
discard.

.i Alternate Strategies ..
Regular defragment will also keep the number of free space slots ._
small. See:
.c com.db4o.tools.Defragment ..
(supplied as source code in ../src/com/db4o/tools)
If defragment can be frequently run, it will also reclaim ._
lost space and decrease the database file to the minimum size. ._
Therefore #discardFreeSpace() may be a good tuning mechanism ._
for setups with frequent defragment runs.


.1 Calling constructors ..
.c Db4o.configure().callConstructors(true); ..
.i Advantage ..
will configure db4o to use constructors to instantiate ._
objects.

.i Effect ..
On VMs where this is supported (Sun Java VM > 1.4, .NET, Mono) ._
db4o tries to create instances of objects without calling ._
a constructor. db4o is using reflection for this feature ._
so this may be considerably slower than using a constructor. For ._
the best performance it is recommended to add a public zero-parameter ._
constructor to every persistent class and to turn constructors on.

.i Alternate Strategies ..
Constructors can also be turned on for individual classes only with
.c Db4o.configure().objectClass(Foo.class).callConstructor(true); ..
There are some classes (e.g. java.util.Calendar) that require a constructor ._
to be called to work. Further details can be found in the ._
.l Constructors chapter on Constructors .. . 


.1 Turning Off Weak References ..
.c Db4o.configure().weakReferences(false); ..
.i Advantage ..
will configure db4o to use hard direct references instead of weak ._
references to control instantiated and stored objects.

.i Effect ..
A db4o database keeps a reference to all persistent objects that are ._
currently held in RAM, whether they were stored to the database in ._
this session or instantiated from the database in this session. ._
This is how db4o can "know" than an object is to be updated: Any ._
"known" object must be an update, any "unknown" object will be ._
stored as "new". (Note that the reference system will only be in ._
place as long as an ObjectContainer is open. Closing and reopening an ._
ObjectContainer will clean the references system of the ObjectContainer ._
and all objects in RAM will be treated as "new" afterwards.) In the ._
default configuration db4o uses weak references and a dedicated thread ._
to clean them up after objects have been garbage collected by the VM. ._
Weak references need extra ressources and the cleanup thread will ._
have a considerable impact on performance since it has to be synchronized ._
with the normal operations within the ObjectContainer. Turning off weak ._
references will improve speed. 
The downside: To prevent memory consumption from growing consistantly, ._
the application has to take care of removing unused objects from the db4o ._
reference system by itself. This can be done by calling
.c ExtObjectContainer.purge(object); ..

.i Alternate Strategies ..
.c ExtObjectContainer.purge(object); ..
can also be called in normal weak reference operation mode to remove ._
an object from the reference cache. This will help to keep the reference ._
tree as small as possible. ._
After calling #purge(object) an object will be unknown to the ._
ObjectContainer so this feature is also suitable for batch inserts. 


.1 Defragment ..
.c new Defragment().run("db.yap", delete); ..
.i Advantage ..
It is recommended to run Defragment frequently to reduce the database ._
file size and to remove unused fields and freespace slots.

.i Effect ..
db4o does not discard fields from the database file that are no longer ._
being used. Within the database file quite a lot of space is used for ._
transactional processing. Objects are always written to a new slot ._
when they are modified. Deleted objects continue to occupy 8 bytes ._
until the next Defragment run. Defragment cleans all this up by writing ._
all objects to a completely new database file. The resulting file will ._
be smaller and faster.

.i Alternate Strategies ..
Instead of deleting objects it can be an option to mark objects as ._
deleted with a "deleted" boolean field and to clean them out (by not ._
copying them to the new database file) during the Defragment run. ._
Two advantages: (1) Deleted objects can be restored. (2) ._
In case there are multiple references to a deleted object, none of them ._
would point to null. To clean out objects during the Defragment run, ._
the Defragment source code would have to be modified. ._
com.db4o.tools.Defragment is  .b only supplied as source code ..  to ._
encourage embedding maintenance tasks. ..


.1 No Shutdown Thread ..
.c Db4o.configure().automaticShutDown(false); ..
.i Advantage ..
can prevent the creation of a shutdown thread on some platforms.

.i Effect ..
On some platforms db4o uses a ShutDownHook to cleanly close all ._
database files upon system termination. If a system is terminated ._
without calling ObjectContainer#close() for all open ._
ObjectContainers, these ObjectContainers will still be usable but ._
they will not be able to write back their freespace management ._
system back to the database file. Accordingly database files will be ._
observed to grow.

.i Alternate Strategies ..
Database files can be reduced to their minimal size with
.c com.db4o.tools.Defragment ..
(supplied as source code in /src/com/db4o/tools)


.1 No callbacks ..
.c Db4o.configure().callbacks(false); ..
.i Advantage ..
will prevent db4o from looking for callback methods in all persistent ._
classes on system startup.

.i Effect ..
Upon system startup, db4o will scan all persistent classes for ._
methods with the same signature as the methods defined in ._
com.db4o.ext.ObjectCallbacks, even if the interface is not ._ 
implemented. db4o uses reflection to do so and on constrained ._
environments this can consume quite a bit of time. If callback ._
methods are not used by the application, callbacks can be turned ._
off safely.

.i Alternate Strategies ..
Class configuration features are a good alternative to callbacks. ._
The most recommended mechanism to cascade updates is:
.c Db4o.configure().objectClass("yourPackage.yourClass").cascadeOnUpdate(true);


.1 No schema changes ..
.c Db4o.configure().detectSchemaChanges(false); ..
.i Advantage ..
will prevent db4o from analysing the class structure upon opening a ._
database file.

.i Effect ..
Upon system startup, db4o will use reflection to scan the structure ._
of all persistent classes. This process can take some time, if a large ._
number of classes are present in the database file. For the best ._
possible startup performance on "warm" database files (all classes ._
already analyzed in a previous startup), this feature can be turned off.

.i Alternate Strategies ..
Instead of using one database file to store a huge and complex ._
class structure, a system may be more flexible and faster, if ._
multiple database files are used. In a client/server setup, database ._
files can also be switched from the client side with
.c ((ExtClient)objectContainer).switchToFile(databaseFile); ..


.1 No lock file thread ..
.c Db4o.configure().lockDatabaseFile(false); ..
.i Advantage ..
will prevent the creation of a lock file thread on Java platforms ._
without NIO (< JDK 1.4.1).

.i Effect ..
If file locking is not available on the system, db4o will regularily ._
write a timestamp lock information to the database file, to prevent ._
other VM sessions from accessing the database file at the same ._
time. Uncontrolled concurrent access would inevitably lead to ._
corruption of the database file. If the application ensures that it can ._
not be started multiple times against the database file, db4o file ._
locking may not be necessary.

.i Alternate Strategies ..
Database files can safely be opened from multiple sessions in readonly
mode. Use:
.c Db4o.configure().readOnly(true) ..


.1 No test instances ..
.c Db4o.configure().testConstructors(false); ..
.i Advantage ..
will prevent db4o from creating a test instance of persistent classes ._
upon opening a database file.

.i Effect ..
Upon system startup, db4o attempts to create a test instance of all ._
persistent classes, to ensure that a public zero-parameter ._
constructor is present. This process can take some time, if a large ._
number of classes are present in the database file. For the best ._
possible startup performance this feature can be turned off.

.i Alternate Strategies ..
In any case it's always good practice to create a zero-parameter ._
constructor. If this is not possible because a class from a third party ._
is used, it may be a good idea to write a translator that translates ._
the third party class to one's own class. The dowload comes with ._
the source code of the preconfigured translators in
../src/com/db4o/samples/translators.
The default configuration can be found in the above folder in the file
Default.java/Default.cs
Take a look at the way the built-in translators work to get an idea ._
how to write a translator. It just requires implementing 3 (4 for ._
ObjectConstructors) methods and configuring db4o to use a ._
translator on startup with
.c Db4o.configure().objectClass("yourPackage.yourClass").translate() ..

.1 Increase max database size / block size ..
.c Db4o.configure().blockSize(newBlockSize);
.c Defragment.main(new String[] {"mydb.yap"});

.i Effect ..
Increasing the block size from the default of 1 to a higher value permits ._
you to store more data in a db4o database.

The block size can be between 1 (the default) and 127, which will ._
give you a maximum of 254 GB of storage.


