.n
.a FirstSteps ..
.0 First Steps ..

To get started as simply as possible, we are going to reuse the Pilot class from the db4o tutorial.

.c package f1.singleobject;

public class Pilot {
	String name;
	int points;
} ..

.1 Simple Replication ..

First, we will also use db4o to db4o replication, as it is the simplest and requires the least initial setup.

First, let's open our source database:

.c //Open the source db4o database
ObjectContainer handheld = Db4o.openFile("handheld.yap"); ..

And let's store an object or two:

.c source.set(new Pilot("Scott Felton", 200));
source.set(new Pilot("Frank Green", 120)); ..

Great. Now we need our destination database:

.c //Open the destination db4o database
ObjectContainer desktop = Db4o.openFile("desktop.yap"); ..

When replicating objects to and from a db4o database, we need to enable UUIDs and VersionNumbers. The ._
chapter on  .l db4oReplication db4o replication ..  explains more about these settings. We need to call these settings ._
before opening our database.

.c //Replication requires UUIDs and VersionNumbers
Db4o.configure().generateUUIDs(Integer.MAX_VALUE);
Db4o.configure().generateVersionNumbers(Integer.MAX_VALUE); ..

Now, it's about time we start replicating some data. Let's set up our replication process to replicate some data from ._
our handheld, to our desktop:

.c //And then create the RepplicationSession
ReplicationSession replication = Replication.begin(handheld, desktop); ..

The ReplicationSession object contains all the functionality that the replication system will ._
require to be able to comprehensively replicate modified data from one database to the other.

Now that we've got the ReplicationSession set up and ready, let's get to the meat of this process:

.c //Query for objects changed from db4o
ObjectSet changed = replication.providerA().objectsChangedSinceLastReplication();

//Iterate changed objects, replicate them
while (changed.hasNext())
	replication.replicate(changed.next());
..

This code will get a list of all of the updated objects, and then replicate them to the destination ._
database. Easy! 

But wait, there's one important last step:

.c //commit all of our changes to both databases.
replication.commit(); ..

Ok. NOW we're done. Now the data has been copied, and the transaction is commited. All of our changes ._
are safely commited in case of any failures. 

.1 Bi-Directional Replication ..

Our previous example copied all new or modified objects from our handheld device to our desktop ._
database. What if we want to go the other way? Well, we only have to add one more loop:

.c ObjectSet changed = replication.providerB().objectsChangedSinceLastReplication();

while(changed.hasNext())
	replication.replicate(changed.next()); ..
	
Now our handheld contains all of the new and modified records from our desktop.

Wow, wasn't that easy? Now, if there had been any modifications made to the destination datbase, ._
the two are now both in sync with eachother. Congratulations, you've now syncronized 2 db4o databases!

.1 Selective Replication ..

What if our handheld dosn't have enough memory to store a complete set of all of our data objects? ._
Well, then we should check our objects before replicating them by modifing the while loop:

.c ObjectSet changed = replication.providerB().objectsChangedSinceLastReplication();

while (changed.hasNext()){
	Pilot p = (Pilot)changed.next();
	if(p.name.startsWith("S"))
		replication.replicate(p);
} ..

Now, only Pilots whose name starts with "S" will be replicated to our handheld database.

.1 Conflict Resolution ..

Isn't it great when things work without any fussing? Well, if you're doing bi-directional replication, ._
I'm sure you'll run into plenty of cases where you may have modifications on both your handheld, and ._
your desktop databases. In this case, the dRS replication system allows you to specify your own ._
ReplicationEventListener. Here's a sample:

.c ReplicationEventListener resolver = new ReplicationEventListener() {
	public void onReplicate(ReplicationEvent event) {
		if (event.isConflict()) {
			ObjectState chosenObjectState = event.stateInProviderA();
			event.overrideWith(chosenObjectState);
		}
	}
};

ReplicationSession replication = Replication.begin( handheld, desktop, resolver); ..

This replication provider just picks the object from provider A as the winner. But you can put any ._
amount of checks within the onReplicate method. If a ReplicationEventListener is not specified, ._
ReplicationConflictException will be thrown.

.1 db4o-Hibernate Replication ..

Now let's take it one step further. Let's syncronize our desktop db4o database with a Hibernate-enhanced ._
RDBMS (SQL) database. The first thing we're going to need is a working Hibernate system, so let's start ._
with the Hibernate config xml file:

.c <?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!-- Database connection settings -->
        <property name="hibernate.connection.driver_class">org.hsqldb.jdbcDriver</property>

        <property name="hibernate.connection.url">jdbc:hsqldb:mem:replication</property>
        <property name="hibernate.connection.username">sa</property>
        <property name="hibernate.connection.password"></property>

        <!-- JDBC connection pool (use the built-in) -->
        <property name="hibernate.connection.pool_size">1</property>

        <!-- SQL dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.HSQLDialect</property>

        <!-- Echo all executed SQL to stdout -->
        <property name="hibernate.show_sql">false</property>

        <!-- Update the database schema if out of date -->
        <property name="hibernate.hbm2ddl.auto">update</property>

        <!-- Specify all your data entity classes here -->
        <mapping resource="f1/chapter4_1/Pilot.hbm.xml"/>
    </session-factory>
</hibernate-configuration> ..

Wow, look at all that stuff. At first it looks like a lot, but uppon closer inspection, ._
it's really not much. There's a connection, a username, and a password. The rest of it ._
is of little consequence right except the last <mapping /> tag. We need to add a <mapping /> ._
tag for each type that we are going to attempt to replicate.

To replicate Pilot using Hibernate, you need to define a mapping file for it.

.c <?xml version="1.0"?>

<!DOCTYPE hibernate-mapping PUBLIC
		"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
		"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping default-access="field" default-lazy="false" default-cascade="save-update">
	<class name="f1.singleobject.Pilot">
		<id column="typed_id" type="long">
			<generator class="native"/>
		</id>
		<property name="name"/>
		<property name="points"/>
	</class>
</hibernate-mapping> ..

Now it's just a simple case of reading our configuration files, and starting our replication session.

.c //Read the Hibernate Config file (in the classpath): org.Hibernate.cfg.Configuration namespace
Configuration hibernate = new Configuration().configure("hibernate.cfg.xml");

ReplicationSession replication = Replication.begin(desktop, hibernate); ..

That's the only change necessary to replicate your objects into your new SQL database! Depending ._
on which RDBMS you are running, you may need to select different configuration settings in the ._
Hibernate.config.xml file. The two most common settings that you may need to change are:

- hibernate.connection.url: Set this to the appropriate JDBC driver. For this example, we are ._
using a temporary Hibernate in-memory database.

- hibernate.dialect: Make sure that you're talking to your database in the correct version of ._
SQL. Query formats and DDL language varies widely among different database vendors. See the ._
Hibernate documentation for a list of values.