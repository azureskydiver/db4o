.n
.a Hibernate Replication ..
.0 Hibernate Replication ..

In this chapter, we will look into several examples that showcase the Hibernate Replication feature.
.1 Basics
Let's take a look at what you have to do in order to use the Hibernate Replication feature. ._
The basics are already covered in .l First Steps .. . Let's re-iterate some of the important points:

.2 hibernate.cfg.xml ..
It is important that "hibernate.hbm2ddl.auto" be set to "update" because the system will create some extra tables ._
to store the metadata for replication to work properly.
.c
<property name="hibernate.hbm2ddl.auto">update</property>
..
Also, if there are no tables in the database, Hibernate will create the tables according to the hbm.xml files ._
specified automatically. This way, you can save the time needed in creating tables.

.2 Hibernate mapping files ..
For each persisted class, you need to define a mapping file for Hibernate to understand how to store and load ._
the objects. Here are some important information:

If you do not define getter/setter for property, make default-access="field". default-lazy="false" default-cascade="all" ._
is required for replication to work properly.

.c
<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
..
You must define an artificial identity column for the object.
.c
<id column="id" type="long">
	<generator class="native"/>
</id>
..
For complete reference in using Hibernate, please refer to the Hibernate reference ( .l http://www.hibernate.org/hib_docs/v3/reference/en/html_single/ ..)

.1 Examples ..
.a One-to-one ..
.2 One-to-one ..
A one-to-one association example:
.c
public class Pilot {
	String name;
	Helmet helmet;
}
..
.c
public class Helmet {
	String model;
}
..
A one-to-one association to another persistent class is declared using a one-to-one element.
.c
<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
	<class name="f1.one_to_one.Pilot">
		<id column="id" type="long">
			<generator class="native"/>
		</id>
		<property name="name"/>
		<one-to-one name="helmet" lazy="false"/>
	</class>
</hibernate-mapping>
..
Remember to add mappings in hibernate.cfg.xml
.c
<mapping resource="f1/one_to_one/Pilot.hbm.xml"/>
<mapping resource="f1/one_to_one/Helmet.hbm.xml"/>
..
Now, create and save the pilot. Helmet is saved automatically.
.c
ExtDb4o.configure().generateUUIDs(Integer.MAX_VALUE);
ExtDb4o.configure().generateVersionNumbers(Integer.MAX_VALUE);

ObjectContainer objectContainer = Db4o.openFile("OneToOne.yap");

Helmet helmet = new Helmet();
helmet.model = "Robuster";

Pilot pilot = new Pilot();
pilot.name = "John";
pilot.helmet = helmet;

objectContainer.set(pilot);
objectContainer.commit();
..
.a Perform the replication..
Perform the replication.
.c
Configuration config = new Configuration().configure("f1/one_to_one/hibernate.cfg.xml");

ReplicationSession replication = Replication.begin(objectContainer, config);

ObjectSet changed = replication.providerA().objectsChangedSinceLastReplication();

while (changed.hasNext())
	replication.replicate(changed.next());

replication.commit();
replication.close();
objectContainer.close();
..
Here, helmet is cascaded from pilot and is replicated automatically.
.2 Collection ..
This section covers examples on Collection, including array, Set, List and Map. ._

We will use Car as the element in the following examples.
.c
public class Car {
	public String brand;
	public String model;
}
..
.c
<?xml version="1.0"?>

<!DOCTYPE hibernate-mapping PUBLIC
		"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
		"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
	<class name="f1.collection.Car">
		<id column="id" type="long">
			<generator class="native"/>
		</id>
		<property name="brand"/>
		<property name="model"/>
	</class>
</hibernate-mapping>
..

.3 Array ..
Hibernate supports one dimensional arrays but does not support multidimensional arrays. ._

.c
public class Pilot {
	String name;
	Car[] cars;
}
..
.c
<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
	<class name="f1.collection.array.Pilot">
		<id column="id" type="long">
			<generator class="native"/>
		</id>

		<property name="name"/>

		<array name="cars" table="cars" cascade="all">
			<key column="pilotId"/>
			<list-index column="sortOrder"/>
			<one-to-many class="f1.collection.Car"/>
		</array>
	</class>
</hibernate-mapping>
..
Add Pilot and Car to hibernate.cfg.xml
.c
<mapping resource="f1/collection/array/Pilot.hbm.xml"/>
<mapping resource="f1/collection/Car.hbm.xml"/>
..
Save the pilot as usual and start replication. You are done!
.c
ExtDb4o.configure().generateUUIDs(Integer.MAX_VALUE);
ExtDb4o.configure().generateVersionNumbers(Integer.MAX_VALUE);

ObjectContainer objectContainer = Db4o.openFile("ArrayExample.yap");

Pilot pilot = new Pilot();
pilot.name = "John";

Car car1 = new Car();
car1.brand = "BMW";
car1.model = "M3";

Car car2 = new Car();
car2.brand = "Mercedes Benz";
car2.model = "S600SL";

pilot.cars = new Car[]{car1, car2};

objectContainer.set(pilot);
objectContainer.commit();

Configuration config = new Configuration().configure("f1/collection/array/hibernate.cfg.xml");

ReplicationSession replication = Replication.begin(objectContainer, config);

ObjectSet changed = replication.providerA().objectsChangedSinceLastReplication();

while (changed.hasNext())
	replication.replicate(changed.next());

replication.commit();
replication.close();
objectContainer.close();
..
.3 List ..
Similar to array, you can repliate a List of Cars.
.c
public class Pilot {
	String name;
	List cars;
}
..
Map the List using the list tag in Pilot.hbm.xml
.c
<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
	<class name="f1.collection.list.Pilot">
		<id column="id" type="long">
			<generator class="native"/>
		</id>

		<property name="name"/>

		<list name="cars" table="cars">
			<key column="pilotId"/>
			<list-index column="sortOrder"/>
			<one-to-many class="f1.collection.Car"/>
		</list>
	</class>
</hibernate-mapping>
..
Replicate the pilot
.c
ExtDb4o.configure().generateUUIDs(Integer.MAX_VALUE);
ExtDb4o.configure().generateVersionNumbers(Integer.MAX_VALUE);

ObjectContainer objectContainer = Db4o.openFile("ListExample.yap");

Pilot pilot = new Pilot();
pilot.name = "John";

Car car1 = new Car();
car1.brand = "BMW";
car1.model = "M3";

Car car2 = new Car();
car2.brand = "Mercedes Benz";
car2.model = "S600SL";

pilot.cars = new ArrayList();
pilot.cars.add(car1);
pilot.cars.add(car2);

objectContainer.set(pilot);
objectContainer.commit();

Configuration config = new Configuration().configure("f1/collection/list/hibernate.cfg.xml");

ReplicationSession replication = Replication.begin(objectContainer, config);

ObjectSet changed = replication.providerA().objectsChangedSinceLastReplication();

while (changed.hasNext())
	replication.replicate(changed.next());

replication.commit();
replication.close();
objectContainer.close();
..

.3 Set ..
Replicating a Set of objects is simple and is similar to the List example.
.c
public class Pilot {
	String name;
	Set cars;
}
..
Use the set tag.
.c
<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
	<class name="f1.collection.set.Pilot">
		<id column="id" type="long">
			<generator class="native"/>
		</id>

		<property name="name"/>

		<set name="cars" table="cars">
			<key column="pilotId"/>
			<one-to-many class="f1.collection.Car"/>
		</set>
	</class>
</hibernate-mapping>
..
Begins the replication.
.c
ExtDb4o.configure().generateUUIDs(Integer.MAX_VALUE);
ExtDb4o.configure().generateVersionNumbers(Integer.MAX_VALUE);

ObjectContainer objectContainer = Db4o.openFile("SetExample.yap");

Pilot pilot = new Pilot();
pilot.name = "John";

Car car1 = new Car();
car1.brand = "BMW";
car1.model = "M3";

Car car2 = new Car();
car2.brand = "Mercedes Benz";
car2.model = "S600SL";

pilot.cars = new HashSet();
pilot.cars.add(car1);
pilot.cars.add(car2);

objectContainer.set(pilot);
objectContainer.commit();

Configuration config = new Configuration().configure("f1/collection/set/hibernate.cfg.xml");

ReplicationSession replication = Replication.begin(objectContainer, config);
ObjectSet changed = replication.providerA().objectsChangedSinceLastReplication();

while (changed.hasNext())
	replication.replicate(changed.next());

replication.commit();
replication.close();
objectContainer.close();
..
As you can see, these examples are very similar to each other.
.3 Map ..
Replication supports replicating a Map of objects.
.c
public class Pilot {
	String name;
	Map cars;
}
..
Use the map element to define the Map in the hbm file.
.c
<hibernate-mapping default-access="field" default-lazy="false" default-cascade="all">
	<class name="f1.collection.map.Pilot">
		<id column="id" type="long">
			<generator class="native"/>
		</id>

		<property name="name"/>

		<map name="cars" table="cars">
			<key column="pilotId"/>
			<map-key type="string"/>
			<one-to-many class="f1.collection.Car"/>
		</map>
	</class>
</hibernate-mapping>
..
Begins the replication.
.c
ExtDb4o.configure().generateUUIDs(Integer.MAX_VALUE);
ExtDb4o.configure().generateVersionNumbers(Integer.MAX_VALUE);

ObjectContainer objectContainer = Db4o.openFile("MapExample.yap");

Pilot pilot = new Pilot();
pilot.name = "John";

Car car1 = new Car();
car1.brand = "BMW";
car1.model = "M3";

Car car2 = new Car();
car2.brand = "Mercedes Benz";
car2.model = "S600SL";

pilot.cars = new HashMap();
pilot.cars.put("car1", car1);
pilot.cars.put("car2", car2);

objectContainer.set(pilot);
objectContainer.commit();

Configuration config = new Configuration().configure("f1/collection/map/hibernate.cfg.xml");

ReplicationSession replication = Replication.begin(objectContainer, config);
ObjectSet changed = replication.providerA().objectsChangedSinceLastReplication();

while (changed.hasNext())
	replication.replicate(changed.next());

replication.commit();
replication.close();
objectContainer.close();
..
.2 Summary
Our replication system supports Java array and Collections. Simply use the <one-to-many> or <many-to-many> ._
mappings in hbm files, then you can replicate the objects in Collections successfully.

Remember that a Collection must not be shared by two owners, otherwise, hibernate will throw an exception.

.1 Keeping track of object changes ..
After replication completes, objects are synchronized across db4o and RDBMS. ._
Later, in the next round replication, you can replicate objects that are changed ._
since last round of replication. This section describes how do you configure ._
dRS to detect object changes.

dRS detects object changes by listening the the object update events thrown by Hibernate. ._
In your day to day usage of Hibernate, you can enable the listening by following this code:
.c
// Read or create the Configuration as usual
Configuration cfg = new Configuration().configure("your-hibernate.cfg.xml");
// Let the ReplicationConfigurator adjust the configuration
ReplicationConfigurator.configure(cfg);
// Create the SessionFactory as usual
SessionFactory sessionFactory = cfg.buildSessionFactory();
// Create the Session as usual
Session session = sessionFactory.openSession();
// Let the ReplicationConfigurator install the listeners to the Session
ReplicationConfigurator.install(session, cfg);
..

Here you can see, you can create the Configuration and the Session objects as usual. ._
dRS will automatically install the listeners to Hibernate.

.1 How dRS modifies database schema ..
So far we have seen that dRS allows you to replicate objects between db4o and relational database. ._
You maybe curious that how dRS keeps track of the identity of objects in relational database and how ._
dRS knows which objects are changed since last round of replication. Read on and you will see how ._
dRS does that.

.2 keeping track of the object identity ..
In chapter 3  .l db4oReplication db4o replication ..  , you have already seen that dRS uses UUID to identify an object. ._
To store this metadate in relational database, dRS will do the following:
1) - Creates a "ReplicationProviderSignature" table to store the signature of the database system that originates the object (the second part of UUID)
2) - Creates a "ObjectReference" table to store the UUIDs and version numbers of objects

During replication, dRS will makes use of these tables to uniquely identify objects.

.2 Generating UUID for new objects ..
As mentioned above, object is identified by both the first part and second part of UUID. ._
For objects that originates from the same database, they will share the same second part of UUID. ._
They only differs in the first part of UUID. So dRS needs to have the ability to generate unique ._
first part for each new object.

To do so, dRS generate the first parts of new objects as a sequence of integers. ._
dRS creates a table named "UuidLongPartSequence" to store the current sequence number. ._
When a new object is saved, dRS asks the table for the sequence number and uses it as the first ._
part of UUID of that object.

.2 Replication histories ..
dRS creates a table called "ReplicationRecord" to store the histories of replication. ._
The history contains the signature of the opposite database, version number in a round of ._
replication.

Suppose this database is replicated against 10 different opposite databases. The ReplicationRecord ._
contains 10 records. The maximum of these 10 version number is used as the base version number of ._
next round of replication.

For example, if the maximum version number is 10, then the version number used in the next round of ._
replication is 11. dRS uses this number to compare with the version number of objects. If the object ._
version number is larger than the replication version number, then dRS knows the object is changed since ._
last replication.

.2 List of dRS tables ..

.3 dRS tables ..
 - ReplicationComponentField
 - ReplicationComponentIdentity
 - ReplicationProviderSignature
 - ReplicationRecord
 - UuidLongPartSequence
 - ObjectReference

Oracle 9i/10g dialect of the DDL
.c
create table ObjectReference (id number(19,0) not null, longPart number(19,0) not null, provider number(19,0) not null, className varchar2(255), objectId number(19,0), version number(19,0), deleted char(1), primary key (id), unique (longPart, provider))
create table ReplicationComponentField (id number(19,0) not null, referencingObjectClassName varchar2(255) not null, referencingObjectFieldName varchar2(255) not null, primary key (id), unique (referencingObjectClassName, referencingObjectFieldName))
create table ReplicationComponentIdentity (id number(19,0) not null, uuidLongPart number(19,0) not null, provider number(19,0) not null, referencingObjectUuidLongPart number(19,0) not null, referencingObjectField number(19,0) not null, primary key (id), unique (uuidLongPart, provider))
create table ReplicationProviderSignature (drs_provider_id number(19,0) not null, class varchar2(255) not null, bytes raw(255) not null, creationTime number(19,0), primary key (drs_provider_id))
create table ReplicationRecord (id number(19,0) not null, version number(19,0) not null, primary key (id))
create table UuidLongPartSequence (unused_id number(19,0) not null, current_seq_number number(19,0) not null, primary key (unused_id))
alter table ObjectReference add constraint FK82F9AAAC8071AB25 foreign key (provider) references ReplicationProviderSignature
alter table ReplicationComponentIdentity add constraint FK4BFE028F9FC4B083 foreign key (referencingObjectField) references ReplicationComponentField
alter table ReplicationComponentIdentity add constraint FK4BFE028F8071AB25 foreign key (provider) references ReplicationProviderSignature
alter table ReplicationRecord add constraint FK7F31971DB6D8E1D8 foreign key (id) references ReplicationProviderSignature
..

To find out the dialect of other RDBMS, run any of the dRS example with your RDBMS, set the output level ._
in log4j.xml from "FATAL" to "DEBUG". Search for entries of "SchemaUpdate" , then you will find out the ._
DDL of your RDBMS dialect.

.2 Turning off the automatic creation of dRS tables and columns ..
In some situations, you may not have the privilege to create or alter tables. You may need to ask your DBA ._
to create the tables for you before using dRS.

You can turn off the automatic creation of dRS tables and columns by changing the "hibernate.hbm2ddl.auto" ._
property to "validate" in hibernate.cfg.xml. By doing so, dRS will not create or alter any tables. Rather, ._
it will check the existence of the dRS tables before starting replication.

If the required dRS tables do not exist, dRS will throw a RuntimeException notifying the user ._
and the replication will halt.