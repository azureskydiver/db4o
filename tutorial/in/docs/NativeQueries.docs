.n
.a NativeQueries ..
.0 Native Queries ..

Now we have seen two ways of querying a db4o database, both having their
pros and cons. QBE is quite intuitive and easy but somewhat limited. The
query API covers much more functionality, but it's a bit like a foreign
dialect put on top of your programming language, that in particular isn't
accessible to your IDE's features like type checking, autocompletion and
refactorings.

Wouldn't it be nice to be able to pose queries right in the programming
language you're using? Enter native queries. These are actually going to
become the main query interface for db4o. We decided to not present them
as such in this version of the tutorial, though, since it's meant to be
compatible with legacy Java/.NET versions where native queries are available,
but look a bit clumsy. We'll try to provide a .NET2.0/JDK5.0 specific
version soon where they really can shine.

.1 Native Query Example ..

First we need some database content to work with.

.s com.db4o.f1.chapter1.NQExample#storePilots -out ..

Now assume we wanted to find all pilots with a given name or a score within a
given range. This cannot be expressed with QBE, with the query API this
might look like this, if no builder pattern is applied:

.s com.db4o.f1.chapter1.NQExample#retrieveComplexSODA ..

This version probably looks a bit more familiar, furthermore it's typesafe
and fully accessible to autocompletion, refactoring and other IDE features:

.? net .s com.db4o.f1.chapter1.ComplexQuery ..s ..?

.s com.db4o.f1.chapter1.NQExample#retrieveComplexNQ ..

.? net With .NET 2.0, this becomes much more compact with an anonymous delegate:
.c
IList<Pilot> result=db.Query<Pilot>(delegate(Pilot pilot) {
		return pilot.Points>99
	    		&& pilot.Points<199
	        ||pilot.Name=="Rubens Barrichello";
	});
..c ..?

.? java With JDK 5 generics, we also get increased type safety. 
.c
        List<Pilot> result=db.query(new Predicate<Pilot>() {
        	public boolean match(Pilot pilot) {
        		return pilot.getPoints()>99
        			&& pilot.getPoints()<199
        			||pilot.getName().equals("Rubens Barrichello");
			}
        });
..c ..?

For pre JDK5/.NET2.0 environments without generics, native queries work
by convention: db4o expects a predicate to provide a method with the name
'match()' and a single parameter with the type of the requested class
extent.

.1 Arbitrary Code ..

Basically that's all there is to know about native queries: They are just
plain old language constructs, applied as collection filters. In principle
you can run almost arbitrary code as native queries, you just have to be
very careful with side effects - especially those that might affect
persistent objects.

Let's run an example that involves some more of the language features
available.

.? net .s com.db4o.f1.chapter1.ArbitraryQuery ..s ..?

.s com.db4o.f1.chapter1.NQExample#retrieveArbitraryCodeNQ ..

.1 Native Query Performance ..

The new freedom we've won comes with a drawback, of course: Performance.
Native queries require each candidate object to be instantiated, and
they cannot take advantage of any field indices you may have created.

To overcome this issue, db4o can optionally analyze the bytecode of your
predicate classes and try to convert it to SODA style queries under the
hood. This feature is still under development.

.? java The current state of the query optimization process is detailed
in a  .l NQOptimization separate chapter ..l .
..?

.1 Native Query Concepts ..

If you'd like to learn more about native query concepts and our motivation
to implement them, please refer to these papers:

.l http://www.cs.utexas.edu/users/wcook/papers/SafeQuery/SafeQueryFinal.pdf Cook/Rai, Safe Query Objects: Statically Typed Objects as Remotely Executable Queries ..l
.l http://www.cs.utexas.edu/users/wcook/papers/NativeQueries/NativeQueries8-23-05.pdf Cook/Rosenberger, Native Queries for Persistent Objects, A Design White Paper ..l
