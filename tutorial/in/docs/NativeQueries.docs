.n
.a NativeQueries ..
.0 Native Queries ..

Wouldn't it be nice to pose queries in the programming ._
language that you are using? Wouldn't it be nice if all querying code was ._
100% typesafe, 100% compile-time checked, 100% refactorable? Wouldn't ._
it be nice if the full power of object-orientation could be used ._
by calling methods from within queries? Enter native queries. 

Native queries are the main query interface of db4o and they are the ._
recommended way to query databases from your application. Because native ._
queries simply use the semantics of your programming language, they are ._
perfectly standardized and a safe choice for the future.

When this tutorial was written neither .NET 2.0 nor JDK 5 were the ._
installed base for browsers, so we could not provide running samples ._
with the most modern syntax yet.

Native queries are available for all platforms where db4o is available, ._
for earlier language versions they are just slightly more verbose.



.1 Native Query Example ..

Again we need some database content to work with.

.s com.db4o.f1.chapter1.NQExample#storePilots -out ..

Now assume we wanted to find all pilots with a given name or a score within a ._
given range. This cannot be expressed with QBE, with the query API this ._
might look like this, if no builder pattern is applied:

.s com.db4o.f1.chapter1.NQExample#retrieveComplexSODA ..

This version probably looks a bit more familiar, furthermore it's typesafe ._
and fully accessible to autocompletion, refactoring and other IDE features:

.? net .s com.db4o.f1.chapter1.ComplexQuery ..s ..?

.s com.db4o.f1.chapter1.NQExample#retrieveComplexNQ ..

.? net With .NET 2.0, this becomes much more compact with an anonymous delegate:
.c
IList<Pilot> result=db.Query<Pilot>(delegate(Pilot pilot) {
		return pilot.Points>99
	    		&& pilot.Points<199
	        ||pilot.Name=="Rubens Barrichello";
	});
..c ..?

.? java With JDK 5 generics, we also get increased type safety. 
.c
        List<Pilot> result=db.query(new Predicate<Pilot>() {
        	public boolean match(Pilot pilot) {
        		return pilot.getPoints()>99
        			&& pilot.getPoints()<199
        			||pilot.getName().equals("Rubens Barrichello");
			}
        });
..c ..?

For pre JDK5/.NET2.0 environments without generics, native queries work ._
by convention: db4o expects a Predicate object to provide a method with ._
the name 'match()' and a single parameter with the type of the requested ._
class extent.

.1 Arbitrary Code ..

Basically that's all there is to know about native queries: They are just ._
plain old language constructs, applied as collection filters. In principle ._
you can run almost arbitrary code as native queries, you just have to be ._
very careful with side effects - especially those that might affect ._
persistent objects.

Let's run an example that involves some more of the language features ._
available.

.? net .s com.db4o.f1.chapter1.ArbitraryQuery ..s ..?

.s com.db4o.f1.chapter1.NQExample#retrieveArbitraryCodeNQ ..

.1 Native Query Performance ..

The new freedom we've won comes with a drawback, of course: Performance. ._
Native queries require each candidate object to be instantiated, and ._
they cannot take advantage of any field indices you may have created. ._

To overcome this issue, db4o can optionally analyze the bytecode of your ._
predicate classes and try to convert it to SODA style queries under the ._
hood. This feature is still under development.

With the current implementation, our first example will be run optimized, ._
the second cannot be optimized, yet - we're working on it.

.? java The current state of the query optimization process is detailed ._
in a  .l NQOptimization separate chapter ..l .
..?

.1 Native Query Concepts ..

If you'd like to learn more about native query concepts and our motivation ._
to implement them, please refer to these papers:

.l http://www.cs.utexas.edu/users/wcook/papers/SafeQuery/SafeQueryFinal.pdf Cook/Rai, Safe Query Objects: Statically Typed Objects as Remotely Executable Queries ..l
.l http://www.cs.utexas.edu/users/wcook/papers/NativeQueries/NativeQueries8-23-05.pdf Cook/Rosenberger, Native Queries for Persistent Objects, A Design White Paper ..l

.1 Conclusion ..

That's all very impressive, but now there's three alternative approaches to ._
querying with db4o. Which one to choose? Just a few hints:

- Native queries are going to become the primary querying API for db4o, so they ._
should be preferred in the long run.
- The SODA query API should be chosen when there's an indication that it might ._
enhance performance over native queries, or if one wants to pose ('un-object-oriented') ._
queries that cannot be expressed with NQ, like private member access or traversing ._
object associations in the opposite direction.
- QBE is cute, but restricted. If you like this approach, use it as long as it suits ._
your application's needs.

Of course you can mix these strategies as needed.

We have finished our walkthrough and seen the various ways db4o provides ._
to pose queries. But our domain model is not complex at all, consisting of one class only. Let's have ._
a look at the way db4o handles object associations in the  .l Structured next chapter ..l . For the ._
time being, turning to the SODA query API again.

.1 Full source ..

.s com.db4o.f1.chapter1.NQExample ..

.? net
.s com.db4o.f1.chapter1.ComplexQuery ..
.s com.db4o.f1.chapter1.ArbitraryQuery ..
..?