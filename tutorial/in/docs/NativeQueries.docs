.n
.a NativeQueries ..
.1 Native Queries ..

Wouldn't it be nice to pose queries in the programming ._
language that you are using? Wouldn't it be nice if all your query code was ._
100% typesafe, 100% compile-time checked and 100% refactorable? Wouldn't ._
it be nice if the full power of object-orientation could be used ._
by calling methods from within queries? Enter Native Queries. 

Native queries are the main query interface to db4o and they are the ._
recommended way to query databases from your application. Because native ._
queries simply use the semantics of your programming language, they are ._
perfectly standardized and a safe choice for the future.

Native Queries are available for all platforms supported by db4o.

.2 Concept ..

The concept of native queries is taken from the following two papers:

-  .l http://www.cs.utexas.edu/users/wcook/papers/NativeQueries/NativeQueries8-23-05.pdf Cook/Rosenberger, Native Queries for Persistent Objects, A Design White Paper ..l
-  .l http://www.cs.utexas.edu/users/wcook/papers/SafeQuery/SafeQueryFinal.pdf Cook/Rai, Safe Query Objects: Statically Typed Objects as Remotely Executable Queries ..l

Native Queries provide the ability to run one or more lines ._
of code against all instances of a class. Native query expressions should ._
return true to mark specific instances as part of the result set. ._
db4o will attempt to optimize native query expressions and run them against indexes ._
and without instantiating actual objects, where this is possible.

.2 Simple Example ..
Let's look at how a very simple query ._
will look like in some of the programming languages and dialects that db4o ._
supports:

.b C# .NET 2.0 ..
.c IList <Pilot> pilots = db.Query <Pilot> (delegate(Pilot pilot) {
    return pilot.Points == 100;
}); ..c 

.b Java JDK 5 ..
.c List <Pilot> pilots = db.query(new Predicate<Pilot>() {
    public boolean match(Pilot pilot) {
        return pilot.getPoints() == 100;
    }
}); ..c

.b Java JDK 1.2 to 1.4 ..
.c List pilots = db.query(new Predicate() {
    public boolean match(Pilot pilot) {
        return pilot.getPoints() == 100;
    }
}); ..c

.b Java JDK 1.1 ..
.c ObjectSet pilots = db.query(new PilotHundredPoints());

public static class PilotHundredPoints extends Predicate {
    public boolean match(Pilot pilot) {
        return pilot.getPoints() == 100;
    }
} ..c

.b C# .NET 1.1 ..
.c IList pilots = db.Query(new PilotHundredPoints());

public class PilotHundredPoints : Predicate {
    public boolean Match(Pilot pilot) {
        return pilot.Points == 100;
    }
} ..c

.b VB .NET 1.1 ..
.c Dim pilots As IList = db.Query(new PilotHundredPoints())

Public Class PilotHundredPoints Implements Predicate
	Public Function Match (pilot As Pilot) as Boolean
		If pilot.Points = 100 Then 
			Return True 
		Else 
			Return False
	End Function
End Class ..c

A side note on the above syntax:
Native queries for all language dialects where generics are ._
not available work by convention. A class that extends the ._
com.db4o.Predicate class is expected to have a #match() or #Match() method ._
that has one parameter to describe the class extent and ._
returns a boolean variable:

.? java .c boolean match(Pilot candidate); ..c  ..?  ._
.? net .c bool Match(Pilot candidate); ..c   ..?

Clearly, native queries look a lot nicer with the most modern ._
syntax. For very simple queries against single fields you may ._
find the  .l SODAQueryAPI SODA Query API ..  more convenient.

Don't forget the features of your IDE to produce the frame of ._
a native query with very little typing: You can use code ._
templates with auto-completion or snippet insertion.

As soon as queries become more complex, the advantages ._
of simply being able to use getters, properties, navigation and ._
method calls in a typsafe and compile-time checked way from ._
within a query become obvious. Let's take a look:

.2 Advanced Example ..
Let's compare to a SODA query with some degree of complexity. ._
If we add some content to the database, we can execute ._
that one:

.s com.db4o.f1.chapter1.NQExample#storePilots -out ..

To find all pilots with a given name or a score within a ._
given range the SODA query will look like this:

.s com.db4o.f1.chapter1.NQExample#retrieveComplexSODA ..

Here is how the same query will look like with native queries, ._
fully accessible to autocompletion, refactoring and other IDE ._
features, fully checked at compile time:

.b C# .NET 2.0 ..
.c IList <Pilot> result = db.Query<Pilot> (delegate(Pilot pilot) {
    return pilot.Points > 99
        && pilot.Points < 199
        || pilot.Name == "Rubens Barrichello";
}); ..c 

.b Java JDK 5 ..
.c List <Pilot> result = db.query(new Predicate<Pilot>() {
    public boolean match(Pilot pilot) {
        return pilot.getPoints() > 99
            && pilot.getPoints() < 199
            || pilot.getName().equals("Rubens Barrichello");
   }
}); ..c

.2 Arbitrary Code ..
Basically that's all there is to know about native queries to be able ._
to use them efficiently. In principle ._
you can run arbitrary code as native queries, you just have to be ._
very careful with side effects - especially those that might affect ._
persistent objects.

Let's run an example that involves some more of the language features ._
available.
.? net .s com.db4o.f1.chapter1.ArbitraryQuery ..s  ..?
.? java .s com.db4o.f1.chapter1.NQExample#retrieveArbitraryCodeNQ ..s  ..?

.2 Native Query Performance ..
If this all sounds to good to be true, we have to point out one ._
drawback: Under the hood db4o tries to analyze native queries to ._
convert them to SODA. This is not possible for all queries. ._
For some queries it is very difficult to analyze the flowgraph. ._
The development of the native query optimization processor will ._
be an ongoing process in a close dialog with the db4o community. ._
Feel free to contribute your results and your needs by providing ._
feedback to our  .l http://forums.db4o.com/ db4o forums .. .
.? java The current state of the query optimization process is detailed ._
in the chapter on  .l NQOptimization Native Query Optimization ..l. ..?

With the current implementation, our first example above will run ._
optimized, the second cannot be optimized yet - we are working on it.

.2 Conclusion ..
Now you have been provided with three alternative approaches to query ._
db4o databases: Query-By-Example, SODA, Native Queries.	

Which one is the best to use? Some hints:
- Native queries are targetted to be the primary interface for db4o, so they ._
should be preferred.
- With the current state of the native query optimizer there may be queries ._
that will execute faster in SODA style, so it can be used to tune applications. ._
SODA can also be more convenient for constructing dynamic queries at runtime.
- Query-By-Example is nice for simple one-liners, but restricted in ._
functionality. If you like this approach, use it as long as it suits your ._
application's needs.

Of course you can mix these strategies as needed.

We have finished our walkthrough and seen the various ways db4o provides ._
to pose queries. But our domain model is not complex at all, consisting of ._
one class only. Let's have ._
a look at the way db4o handles object associations in the  .l Structured next chapter ..l . For the ._
time being, turning to the SODA query API again.

.2 Full source ..

.s com.db4o.f1.chapter1.NQExample ..

.? net
.s com.db4o.f1.chapter1.ComplexQuery ..
.s com.db4o.f1.chapter1.ArbitraryQuery ..
..?