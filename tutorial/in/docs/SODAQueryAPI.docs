.n
.a SODAQueryAPI ..
.1 SODA Query API ..

We have already seen how to retrieve objects from db4o via Query By Example. 
While the QBE approach ._
is easy and intuitive, there are situations where it is not sufficient.

- There are queries that simply cannot be expressed with QBE: Retrieve all ._
pilots with more than 100 points, for example.
- Creating a prototype object may have unwanted side effects.
- Default values (e.g. null) may not be accepted by the domain class constructor.
- We may want to query for field default values.

For all of the above cases and more db4o provides  .l NativeQueries .. ._
and the SODA query API.

.l NativeQueries  .. are the main db4o query interface so you may ._
consider to skip to the  .l NativeQueries next chapter ..  immediately, ._
where they are explained.

Because  .l NativeQueries ..  are wrapped to SODA under the hood and because ._
some of the examples in the next chapter refer to SODA, the SODA query API is ._
explained first.

We need some pilots in our database again to explore it.

.s com.db4o.f1.chapter1.QueryExample#storeFirstPilot ..

.s com.db4o.f1.chapter1.QueryExample#storeSecondPilot ..

.2 Simple queries ..

First, let's see how our familiar QBE queries are expressed within the query ._
API. This is done by retrieving a 'fresh' Query object from the ObjectContainer ._
and adding Constraint instances to it. To find all Pilot instances, we constrain the ._
query with the Pilot class object.

.s com.db4o.f1.chapter1.QueryExample#retrieveAllPilots ..

Basically, we're exchanging our 'real' prototype for a meta description of ._
the objects we'd like to hunt down: a .b  query graph ..  made up of ._
query nodes and constraints. A query node is a placeholder for a candidate ._
object, a constraint decides whether to add or exclude candidates from the result.

Our first simple graph looks like this.

.g querygraph/1.gif ..

We're just asking any candidate object (here: any object in the database) ._
to be of type Pilot to aggregate our result.

To retrieve a pilot by name, we have to further constrain the candidate ._
pilots by descending to their name field and constraining this with the ._
respective candidate String.

.s com.db4o.f1.chapter1.QueryExample#retrievePilotByName ..

What does 'descend' mean here? Well, just as we did in our 'real' prototypes, ._
we can attach constraints to child members of our candidates.

.g querygraph/2.gif ..

So a candidate needs to be of type Pilot and have a member named 'name' ._
that is equal to the given String to be accepted for the result.

Note that the class constraint is not required: If we left it out, we would ._
query for all objects that contain a 'name' member with the given value. In ._
most cases this will not be the desired behavior, though.

Finding a pilot by exact points is analogous, we just have to cross ._
the Java primitive/object divide.

.s com.db4o.f1.chapter1.QueryExample#retrievePilotByExactPoints ..

.2 Advanced queries ..

Now there are occasions when we don't want to query for exact field values, but ._
rather for value ranges, objects not containing given member values, etc. This functionality ._
is provided by the Constraint API.

First, let's negate a query to find all pilots who are not Michael Schumacher:

.s com.db4o.f1.chapter1.QueryExample#retrieveByNegation ..

Where there is negation, the other boolean operators can't be too far.

.s com.db4o.f1.chapter1.QueryExample#retrieveByConjunction ..

.s com.db4o.f1.chapter1.QueryExample#retrieveByDisjunction ..

We can also constrain to a comparison with a given value.

.s com.db4o.f1.chapter1.QueryExample#retrieveByComparison ..

The query API also allows to query for field default values. ._

.s com.db4o.f1.chapter1.QueryExample#retrieveByDefaultFieldValue ..

It is also possible to have db4o sort the results.

.s com.db4o.f1.chapter1.QueryExample#retrieveSorted ..

All these techniques can be combined arbitrarily, of course. Please try ._
it out. There still may be cases left where the predefined query API ._
constraints may not be sufficient - don't worry, you can always define ._
your own by providing Evaluation implementations which will be covered ._
in a  .l Evaluations later chapter .. .

To prepare for the next chapter, let's clear the database.

.s com.db4o.f1.chapter1.QueryExample#clearDatabase ..

.2 Conclusion ..
Now you have been provided with three alternative approaches to query ._
db4o databases: Query-By-Example, Native Queries, SODA.

Which one is the best to use? Some hints:
- Native queries are targetted to be the primary interface for db4o, so they ._
should be preferred.
- With the current state of the native query optimizer there may be queries ._
that will execute faster in SODA style, so it can be used to tune applications. ._
SODA can also be more convenient for constructing dynamic queries at runtime.
- Query-By-Example is nice for simple one-liners, but restricted in ._
functionality. If you like this approach, use it as long as it suits your ._
application's needs.

Of course you can mix these strategies as needed.

We have finished our walkthrough and seen the various ways db4o provides ._
to pose queries. But our domain model is not complex at all, consisting of ._
one class only. Let's have ._
a look at the way db4o handles object associations in the  .l Structured next chapter ..l .

.2 Full source ..

.s com.db4o.f1.chapter1.QueryExample ..
