.n
.a SODAQueryAPI ..
.1 SODA Query API ..

The SODA query API is db4o's low level querying API, allowing direct access ._
to nodes of query graphs. Since SODA uses strings to identify fields, it is ._
neither perfectly typesafe nor compile-time checked and it also is quite ._
verbose to write.

For most applications  .l NativeQueries Native Queries ..  will be the better ._
querying interface.

However there can be applications where dynamic generation of queries ._
is required, that's why SODA is explained here.

.2 Simple queries ..

Let's see how our familiar QBE queries are expressed with SODA. A new Query object ._
is created through the #query() method of the ObjectContainer and we can add ._
Constraint instances to it. To find all Pilot instances, we constrain the ._
query with the Pilot class object.

.s com.db4o.f1.chapter1.QueryExample#retrieveAllPilots ..

Basically, we are exchanging our 'real' prototype for a meta description of ._
the objects we'd like to hunt down: a .b  query graph ..  made up of ._
query nodes and constraints. A query node is a placeholder for a candidate ._
object, a constraint decides whether to add or exclude candidates from the result.

Our first simple graph looks like this.

.g querygraph/1.gif ..

We're just asking any candidate object (here: any object in the database) ._
to be of type Pilot to aggregate our result.

To retrieve a pilot by name, we have to further constrain the candidate ._
pilots by descending to their name field and constraining this with the ._
respective candidate String.

.s com.db4o.f1.chapter1.QueryExample#retrievePilotByName ..

What does 'descend' mean here? Well, just as we did in our 'real' prototypes, ._
we can attach constraints to child members of our candidates.

.g querygraph/2.gif ..

So a candidate needs to be of type Pilot and have a member named 'name' ._
that is equal to the given String to be accepted for the result.

Note that the class constraint is not required: If we left it out, we would ._
query for all objects that contain a 'name' member with the given value. In ._
most cases this will not be the desired behavior, though.

Finding a pilot by exact points is analogous. .? java We just have to cross ._
the Java primitive/object divide. ..?

.s com.db4o.f1.chapter1.QueryExample#retrievePilotByExactPoints ..

.2 Advanced queries ..

Now there are occasions when we don't want to query for exact field values, but ._
rather for value ranges, objects not containing given member values, etc. This functionality ._
is provided by the Constraint API.

First, let's negate a query to find all pilots who are not Michael Schumacher:

.s com.db4o.f1.chapter1.QueryExample#retrieveByNegation ..

Where there is negation, the other boolean operators can't be too far.

.s com.db4o.f1.chapter1.QueryExample#retrieveByConjunction ..

.s com.db4o.f1.chapter1.QueryExample#retrieveByDisjunction ..

We can also constrain to a comparison with a given value.

.s com.db4o.f1.chapter1.QueryExample#retrieveByComparison ..

The query API also allows to query for field default values. ._

.s com.db4o.f1.chapter1.QueryExample#retrieveByDefaultFieldValue ..

It is also possible to have db4o sort the results.

.s com.db4o.f1.chapter1.QueryExample#retrieveSorted ..

All these techniques can be combined arbitrarily, of course. Please try ._
it out. There still may be cases left where the predefined query API ._
constraints may not be sufficient - don't worry, you can always let ._
db4o run any arbitrary code that you provide in an Evaluation. ._
Evaluations will be discussed ._
in a  .l Evaluations later chapter .. .

To prepare for the next chapter, let's clear the database.

.s com.db4o.f1.chapter1.QueryExample#clearDatabase ..

.2 Conclusion ..
Now you have been provided with three alternative approaches to query ._
db4o databases: Query-By-Example, Native Queries, SODA.

Which one is the best to use? Some hints:
- Native queries are targetted to be the primary interface for db4o, so they ._
should be preferred.
- With the current state of the native query optimizer there may be queries ._
that will execute faster in SODA style, so it can be used to tune applications. ._
SODA can also be more convenient for constructing dynamic queries at runtime.
- Query-By-Example is nice for simple one-liners, but restricted in ._
functionality. If you like this approach, use it as long as it suits your ._
application's needs.

Of course you can mix these strategies as needed.

We have finished our walkthrough and seen the various ways db4o provides ._
to pose queries. But our domain model is not complex at all, consisting of ._
one class only. Let's have ._
a look at the way db4o handles object associations in the  .l Structured next chapter ..l .

.2 Full source ..

.s com.db4o.f1.chapter1.QueryExample ..
