.0 Native Query Optimization

Native queries will run out of the box in any environment - they ._
will just be executed as SODA evaluations. This has the downside ._
that all candidate objects will have to be instantianted to run ._
the evaluation against them, and that evaluations cannot take ._
advantage of any indices you might have configured.

In optimized mode, native queries are converted to plain SODA ._
queries, if possible. (Otherwise they're just run unoptimized.) ._
This feature is still experimental and will only cover basic ._
use cases. Currently optimization supports:

- constants
- simple member access
- simple getter methods
- chaining of member access/simple getter methods
- primitive comparisons
- String#equals()
- arithmetic expressions
- boolean expressions

Any native query that contains constructs not on this list will ._
be run in unoptimized mode. This list will be constantly extended.

.a Analysis at query execution time

.b Note: This won't work with JDK1.1. ..

To enable code analysis and generation of a corresponding live SODA ._
query at query execution time, you just have to add db4o-5.0-nqopt.jar ._
to your class path and start your application with

-Ddb4o.dynamicnq

as a VM parameter or call

System.setProperty("db4o.dynamicnq","true");

from within your application.
 
.a Instrumenting class files

.b Note: The resulting optimized classes will work for JDK1.1, but not ._
the optimization process itself. ..

File instrumentation can be done either programmatically or during an ._
Ant build.

To instrument all predicate classes in directory 'orig' whose package ._
name starts with 'my.package' and store the modified files below ._
directory 'instrumented', ensure the bloat jar is on your class path ._
and use code like the following:

new com.db4o.nativequery.main.Db4oFileEnhancer()
  .enhance(
    "orig",             // source directory
    "instrumented",     // target directory
    new String[]{       // class path
      "lib/my_application.jar",
      "lib/db4o-5.0-java1.x.jar"
    },
    "my.package"        // optional package prefix
  );
  
An equivalent Ant snippet might look like this:

<taskdef name="db4ooptimize" 
         classname="com.db4o.nativequery.main.Db4oFileEnhancerAntTask">
  <classpath>
    <path path="lib/db4o-5.0-java1.x.jar" />
    <path path="lib/db4o-5.0-nqopt.jar" />
    <path path="lib/bloat-1.0.jar" />
    <path path="lib/db4o-5.0-java1.x.jar" />
  </classpath>
</taskdef>

<target name="optimize">
  <db4ooptimize 
      srcdir="orig" 
      targetdir="instrumented" 
      packagefilter="my.package">
    <classpath>
      <path location="lib/my_application.jar" />
      <path path="lib/db4o-5.0-java1.x.jar" />
    </classpath>
  </db4oenhance>
</target>

All non-Predicate classes will just be copied to the target directory.

.a Instrumenting classes at load time

.b Note: This won't work with JDK1.1. ..

To instrument an existing application on startup, db4o wraps its ._
execution in a custom class loader. To apply this class loader ._
manually, use code like this:

ClassLoader loader=
  new com.db4o.nativequery.main.Db4oEnhancingClassLoader();
Class clazz=loader.loadClass("my.StarterClass");
Method method=clazz.getMethod("someStaticMethod",new Class[]{});
method.invoke(null,new Object[]{});

(Of course the method needn't be static and can have parameters, ._
too.)

To start a full application in optimized mode, you can use the ._
Db4oRunner utility class. If you'd normally start your application ._
like this:

$> java my.StarterClass some arguments

...start Db4oRunner with the fully qualified name of your main class ._
as the first argument and the actual arguments appended:

$> java com.db4o.nativequery.main.Db4oRunner my.StarterClass some arguments

Still to be evaluated:

- Setting the system class loader
  (-Djava.system.class.loader=com.db4o.nativequery.main.Db4oEnhancingClassLoader)
- Configuring Tomcat to use the optimizing class loader
  (Tomcat server.xml <Loader/> section)
  
.a Monitoring optimization

This feature still is as basic as it can get and will soon be improved. ._
Currently you can just attach a listener to the ObjectContainer:

((YapStream)db).addListener(new Db4oQueryExecutionListener() {
  public void notifyQueryExecuted(Predicate pred, String msg) {
    System.err.println(msg);
  }
});

The listener will be notified on each native query call and will be ._
passed the Predicate object processed and the success status of the ._
optimization run:

YapStream.UNOPTIMIZED ("UNOPTIMIZED")
  if the predicate could not be optimized and is run in unoptimized mode
YapStream.PREOPTIMIZED ("PREOPTIMIZED")
  if the predicate already was optimized (due to class file or load time
  instrumentation)
YapStream.DYNOPTIMIZED ("DYNOPTIMIZED")
  if the predicate was optimized at query execution time